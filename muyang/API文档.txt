API文档
跳转到新版
感谢您使用JoinQuant（聚宽）量化交易平台，以下内容主要介绍聚宽量化交易平台的API使用方法，目录中带有"♠" 标识的API是 "回测环境/模拟"的专用API，不能在研究模块中调用。

内容较多，可使用Ctrl+F进行搜索。

如果以下内容仍没有解决您的问题，请您通过社区提问的方式告诉我们，谢谢。

开始写策略
简单但是完整的策略
先来看一个简单但是完整的策略:

def initialize(context):
    # 定义一个全局变量, 保存要操作的股票
    g.security = '000001.XSHE'
    # 运行函数
    run_daily(market_open, time='every_bar')

def market_open(context):
    if g.security not in context.portfolio.positions:
        order(g.security, 1000)
    else:
        order(g.security, -800)
一个完整策略只需要两步:

设置初始化函数: [initialize],上面的例子中, 只操作一支股票: '000001.XSHE', 平安银行
实现一个函数, 来根据历史数据调整仓位.
这个策略里, 每当我们没有股票时就买入1000股, 每当我们有股票时又卖出800股, 具体的下单API请看order函数.

这个策略里, 我们有了交易, 但是只是无意义的交易, 没有依据当前的数据做出合理的分析

下面我们来看一个真正实用的策略

实用的策略
在这个策略里, 我们会根据历史价格做出判断:

如果上一时间点价格高出五天平均价1%, 则全仓买入
如果上一时间点价格低于五天平均价, 则空仓卖出
# 导入聚宽函数库
import jqdata

# 初始化函数，设定要操作的股票、基准等等
def initialize(context):
    # 定义一个全局变量, 保存要操作的股票
    # 000001(股票:平安银行)
    g.security = '000001.XSHE'
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 运行函数
    run_daily(market_open, time='every_bar')

# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次
def market_open(context):
    security = g.security
    # 获取股票的收盘价
    close_data = attribute_history(security, 5, '1d', ['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.cash

    # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    if current_price > 1.01*MA5:
        # 用所有 cash 买入股票
        order_value(security, cash)
        # 记录这次买入
        log.info("Buying %s" % (security))
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)
        # 记录这次卖出
        log.info("Selling %s" % (security))
    # 画出上一时间点价格
    record(stock_price=current_price)
用户需要实现的函数
initialize
initialize(context)
初始化方法，在整个回测、模拟实盘中最开始执行一次，用于初始一些全局变量

参数 context: Context对象, 存放有当前的账户/股票持仓信息

返回 None

示例

def initialize(context):
    # g为全局变量
    g.security = "000001.XSHE"
定时运行函数, 可选
run_monthly
run_weekly
run_daily
def initialize(context):
    # 按月运行
    run_monthly(func, monthday, time='open', reference_security)
    # 按周运行
    run_weekly(func, weekday, time='open', reference_security)
    # 每天内何时运行
    run_daily(func, time='open', reference_security)
具体参见定时运行

参数

参数	解释
func	一个函数, 此函数必须接受context参数
monthday	每月的第几个交易日, 可以是负数, 表示倒数第几个交易日。如果超出每月总交易日个数，则取临近的交易日执行。（具体见下方注意中的示例）
weekday	每周的第几个交易日, 可以是负数, 表示倒数第几个交易日。如果超出每周总交易日个数，则取临近的交易日执行。（具体见下方注意中的示例）
time	一个字符串,可以是具体执行时间,支持 time 表达式。比如 "10:00", "01:00", 或者 "every_bar", "open", "before_open", "after_close", "morning" 和 "night"。(具体执行时间如见下方)

time 表达式具有 'base +/-offset' 的形式，如：'open-30m'表示开盘前30分钟，'close+1h30m'表示收盘后一小时三十分钟。当使用 'base +/-offset' 形式的表达式时， base 只能使用 open 或 close 二者之一。
reference_security	时间的参照标的，默认为‘000001.XSHG’。
如参照 '000001.XSHG'，交易时间为 9:30-15:00。
如参照'IF1512.CCFX'，2016-01-01之后的交易时间为 9:30-15:00，在此之前为 9:15-15:15。
如参照'A9999.XDCE'，因为有夜盘，因此开始时间为21:00，结束时间为15:00。
time	具体执行时间
具体时间	24小时内的任意时间，如"10:00", "01:00"
every_bar	只能在 run_daily 中调用； 按天会在每天的开盘时调用一次，按分钟会在每天的每分钟运行
open	开盘时运行(等同于"9:30")
before_open	早上 9:00 运行
after_close	下午 15:30 运行
morning	早上 8:00 运行
night	晚上 20:00 运行
返回
None

示例

def weekly(context):
    print 'weekly %s %s' % (context.current_dt, context.current_dt.isoweekday())


def monthly(context):
    print 'monthly %s %s' % (context.current_dt, context.current_dt.month)


def daily(context):
    print 'daily %s' % context.current_dt


def initialize(context):

    # 指定每月第一个交易日, 在开盘后一小时10分钟执行
    run_monthly(monthly, 1, 'open + 1h10m')

    # 指定每天收盘前10分钟运行
    run_daily(daily, 'close - 10m')

    # 指定每天收盘后执行
    run_daily(daily, 'after_close')

    # 指定在每天的10:00运行
    run_daily(daily, '10:00')

    # 参照股指期货的时间每分钟运行一次, 必须选择分钟回测, 否则每天执行
    run_daily(daily, 'every_bar', reference_security='IF1512.CCFX')
handle_data, 可选
handle_data(context, data)
该函数每个单位时间会调用一次, 如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次。

该函数依据的时间是股票的交易时间，即 9:30 - 15:00. 期货请使用[定时运行]函数。

该函数在回测中的非交易日是不会触发的（如回测结束日期为2016年1月5日，则程序在2016年1月1日-3日时，handle_data不会运行，4日继续运行）。

对于使用当日开盘价撮合的日级模拟盘，在9:25集合竞价完成时就可以获取到开盘价，出于减少并发运行模拟盘数量的目的，我们会提前到9:27~9:30之间运行, 策略内获取到逻辑时间(context.current_dt)仍然是 9:30。

参数 context: Context对象, 存放有当前的账户/标的持仓信息 data: 一个字典(dict), key是股票代码, value是当时的SecurityUnitData 对象. 存放前一个单位时间(按天回测, 是前一天, 按分钟回测, 则是前一分钟) 的数据. 注意:

为了加速, data 里面的数据是按需获取的, 每次 handle_data 被调用时, data 是空的 dict, 当你使用 data[security] 时该 security 的数据才会被获取.
data 只在这一个时间点有效, 请不要存起来到下一个 handle_data 再用
注意, 要获取回测当天的开盘价/是否停牌/涨跌停价, 请使用 [get_current_data]
返回
None

示例

def handle_data(context, data):
    order("000001.XSHE",100)
before_trading_start, 可选
before_trading_start(context)
该函数会在每天开始交易前被调用一次, 您可以在这里添加一些每天都要初始化的东西.

该函数依据的时间是股票的交易时间，即该函数启动时间为 9:00. 期货请使用[定时运行]函数，time 参数设定为'before_open' 。

参数 context: Context对象, 存放有当前的账户/股票持仓信息

返回 None

示例

def before_trading_start(context):
    log.info(str(context.current_dt))
after_trading_end, 可选
after_trading_end(context)
该函数会在每天结束交易后被调用一次, 您可以在这里添加一些每天收盘后要执行的内容. 这个时候所有未完成的订单已经取消.

该函数依据的时间是股票的交易时间，即该函数启动时间为 15:30. 期货请使用[定时运行]函数，time 参数设定为'after_close' 。

参数 context: Context对象, 存放有当前的账户/股票持仓信息

返回 None

示例

def after_trading_end(context):
    log.info(str(context.current_dt))
process_initialize, 可选
process_initialize(context)
该函数会在每次模拟盘/回测进程重启时执行, 一般用来初始化一些不能持久化保存的内容. 在 [initialize] 后执行.

因为模拟盘会每天重启, 所以这个函数会每天都执行.

参数 context: Context对象, 存放有当前的账户/股票持仓信息

返回 None

示例

def process_initialize(context):
    # query 对象不能被 pickle 序列化, 所以不能持久保存, 所以每次进程重启时都给它初始化
    # 以两个下划线开始, 系统序列化 [g] 时就会自动忽略这个变量, 更多信息, 请看 [g] 和 [模拟盘注意事项]
    g.__q = query(valuation)

def handle_data(context, data):
    get_fundamentals(g.__q)
on_strategy_end, 可选
def on_strategy_end(context)
在回测、模拟交易正常结束时被调用， 失败时不会被调用。

在模拟交易到期结束时也会被调用， 手动在到期前关闭不会被调用。

参数 context: Context对象, 存放有当前的账户/股票持仓信息

返回 None

示例

def on_strategy_end(context):
    print '回测结束'
after_code_changed, 可选
after_code_changed(context)
模拟盘在每天的交易时间结束后会休眠，第二天开盘时会恢复，如果在恢复时发现代码已经发生了修改，则会在恢复时执行这个函数。 具体的使用场景：可以利用这个函数修改一些模拟盘的数据。

注意: 因为一些原因, 执行回测时这个函数也会被执行一次, 在 [process_initialize] 执行之前执行.

参数 context: Context对象, 存放有当前的账户/股票持仓信息

返回 None

示例

def after_code_changed(context):
    g.stock = '000001.XSHE'
回测引擎介绍
回测环境
回测引擎运行在Python2.7之上, 请您的策略也兼容Python2.7
我们支持所有的Python标准库和部分常用第三方库, 具体请看: python库. 另外您可以把.py文件放在研究根目录, 回测中可以直接import, 具体请看: 自定义python库
安全是平台的重中之重, 您的策略的运行也会受到一些限制, 具体请看: 安全
回测过程
准备好您的策略, 选择要操作的股票池, 实现handle_data函数
选定一个回测开始和结束日期, 选择初始资金、调仓间隔(每天还是每分钟), 开始回测
引擎根据您选择的股票池和日期, 取得股票数据, 然后每一天或者每一分钟调用一次您的handle_data函数, 同时告诉您现金、持仓情况和股票在上一天或者分钟的数据. 在此函数中, 您还可以调用函数获取任何多天的历史数据, 然后做出调仓决定.
当您下单后, 我们会根据接下来时间的实际交易情况, 处理您的订单. 具体细节参见订单处理
下单后您可以调用get_open_orders取得所有未完成的订单, 调用cancel_order取消订单
您可以在handle_data里面调用record()函数记录某些数据, 我们会以图表的方式显示在回测结果页面
您可以在任何时候调用log.info/debug/warn/error函数来打印一些日志
回测结束后我们会画出您的收益和基准(参见[set_benchmark])收益的曲线, 列出每日持仓,每日交易和一系列风险数据。
数据
股票数据：我们拥有所有A股上市公司2005年以来的股票行情数据、市值数据、财务数据、上市公司基本信息、融资融券信息等。为了避免幸存者偏差，我们包括了已经退市的股票数据。
商品期货：我们支持从2005年以来上海国际能源交易中心、上期所、郑商所、大商所的行情数据，并包含历史产品的数据。
基金数据：我们目前提供了600多种在交易所上市的基金的行情、净值等数据，包含ETF、LOF、分级A/B基金以及货币基金的完整的行情、净值数据等，请点击基金数据查看。
金融期货数据：我们提供中金所推出的所有金融期货产品的行情数据，并包含历史产品的数据。
股票指数：我们支持近600种股票指数数据，包括指数的行情数据以及成分股数据。为了避免未来函数，我们支持获取历史任意时刻的指数成分股信息，具体见get_index_stocks。注意：指数不能买卖
行业板块：我们支持按行业、按板块选股，具体见get_industry_stocks
概念板块：我们支持按概念板块选股，具体见get_concept_stocks
宏观数据：我们提供全方位的宏观数据，为投资者决策提供有力数据支持。
所有的行情数据我们均已处理好前复权信息。
我们当日的回测数据会在收盘后通过多数据源进行校验，并在T+1（第二天）的00:01更新。
我们提供的所有行情K线数据为后对其，标识K线的时间为数据的结束时间。在一分钟K线上，没有09:30，从09:31开始，有15:00的K线，共计240根。表示时间为09:31的一分钟K线，其数据时间为09:25:00~09:30:59，这一分钟的开盘价是09:25的集合竞价的价格。
安全
保证您的策略安全是我们的第一要务
在您使用我们网站的过程中, 我们全程使用https传输
策略会加密存储在数据库
回测时您的策略会在一个安全的进程中执行, 我们使用了进程隔离的方案来确保系统不会被任何用户的代码攻击, 每个用户的代码都运行在一个有很强限制的进程中:
只能读指定的一些python库文件

不能写和执行任何文件, 如果您需要保存和读取私有文件, 请看[write_file]/[read_file]

不能创建进程或者线程

限制了cpu和内存, 堆栈的使用

可以访问网络, 但是对带宽做了限制, 下载最大带宽为500KB/s, 上传带宽为10KB/s

有严格的超时机制, 如果handle_data超过30分钟则立即停止运行 对于读取回测所需要的数据, 和输出回测结果, 我们使用一个辅助进程来帮它完成, 两者之间通过管道连接.

我们使用了linux内核级别的apparmer技术来实现这一点. 有了这些限制我们确保了任何用户不能侵入我们的系统, 更别提盗取他人的策略了.

运行频率
1. Bar 的概念

在一定时间段内的时间序列就构成了一根 K 线（日本蜡烛图），单根 K 线被称为 Bar。

如果是一分钟内的 Tick 序列，即构成一根分钟 K 线，又称分钟 Bar;
如果是一天内的分钟序列，即构成一根日线 K 线，又称日线 Bar;

Bar 的示意图如下所示：

Bar 的示意图

Bar 就是时间维度上，价格在空间维度上变化构成的数据单元。如下图所示，多个数据单元 Bar 构成的一个时间序列。

K线序列

2. 频率详解

下列图片中齿轮为 handle_data(context, data) 的运行时间，before_trading_start(context) 等其他函数运行时间详见相关API。

频率：天

当选择天频率时， 算法在每根日线 Bar 都会运行一次，即每天运行一次。

在算法中，可以获取任何粒度的数据。

日K线

频率：分钟

当选择分钟频率时， 算法在每根分钟 Bar 都会运行一次，即每分钟运行一次。

在算法中，可以获取任何粒度的数据。

分钟K线

频率：Tick

当选择 Tick 频率时，每当新来一个 Tick，算法都会被执行一次。

执行示意图如下图所示：

Tick序列

订单处理
回测
使用Bar撮合

市价单:

按天回测

当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销
交易价格: 最新价 + [滑点]，如果在开盘时刻运行， 最新价格为开盘价。 其他情况下， 为上一分钟的最后一个价格。
最大成交量: 每次下单成交量不会超过该股票当天的总成交量. 可通过选项 [order_volume_ratio] 设置每天最大的成交量, 例如: 0.25 表示下单成交量不会超过当天成交量的 25%
注意:
context.portfolio 中的持仓价格会使用上一分钟的最后一个价格更新。
data 是昨天的按天数据, 要想拿到当天开盘价, 请使用 [get_current_data] 拿取 day_open 字段
分钟回测

当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销
交易价格: 因为我们是在每分钟的第一秒钟执行代码, 所以价格是上一分钟的最后一个价格 + [滑点]
同按天回测规则, 每次下单成交量不会超过该股票当天的总成交量, [order_volume_ratio] 同样有效.注意: 这是限制了每个订单的成交量, 当然, 你可以通过一天多次下单来超过一天成交量, 但是, 为了对你的回测负责, 请不要这么做.
所有市价单下单之后同步完成(也即 order_XXX 系列函数返回时完成), context.portfolio 会同步变化

限价单

回测(天、分钟):
当 委托价 > 最新价+滑点，按市价单模式撮合
当 委托价 <= 最新价+滑点，则挂单，在Bar结束时按照Bar信息进行撮合：
当 委托价 > bar 的最低价，则成交价为委托价，成交量不超过 Bar 成交量 * order_volume_ratio
天、分钟相同
不是立即完成, 下单之后 context.portfolio.cash 和 context.portfolio.positions 不会同步变化.
按天模拟交易暂时不支持限价单
上述过程中, 如果实际价格已经涨停或者跌停, 则相对应的买单或卖单不成交, 市价单直接取消(log中有警告信息), 限价单会挂单直到可以成交.

一天结束后, 所有未完成的订单会被取消

每次订单完成(完全成交)或者取消后, 我们会根据成交量计算手续费(参见[set_order_cost]), 减少您的现金

更多细节, 请看order函数

模拟交易
1.使用盘口撮合
市价单

买单：
根据卖单盘口进行撮合
优先从卖一档开始撮合，根据成交量算出 加权均价
成交价： 加权均价
5档成交剩余撤销：买入时从“卖一"到“卖五"价格依次成交，卖出时从“买一”到“买五"价格依次成交。若无法全部成交，则剩余未匹配量自动撤销
当前没有盘口时，按照 使用 Bar 处理 处理：
当成交量不为零为，使用最新价+滑点成交
当成交量为零，则取消该订单
卖单：
根据买单盘口进行撮合
优先从买一档开始撮合，根据成交量算出 加权均价
成交价 ： 加权均价
5档成交剩余撤销：买入时从“卖一"到“卖五"价格依次成交，卖出时从“买一”到“买五"价格依次成交。若无法全部成交，则剩余未匹配量自动撤销
当前没有盘口时，按照 使用 Bar 处理 处理：
当成交量不为零为，使用最新价+滑点成交
当成交量为零，则取消该订单
限价单

买单：

根据卖单盘口进行撮合
优先从卖一档开始撮合，直至盘口价格>委托价的档位，根据成交量算出 加权均价
成交价 ： 加权均价
当限价单根据盘口撮合完，为部分成交时，剩余委托数量会在 Bar 结束时根据 Bar 信息进行撮合，详情见Bar撮合方式。
卖单：

根据买单盘口进行撮合
优先从买一档开始撮合，直至盘口价格<委托价的档位，根据成交量算出 加权均价
成交价 ： 加权均价
当限价单根据盘口撮合完，为部分成交时，剩余委托数量会在 Bar 结束时根据 Bar 信息进行撮合，详情见 Bar 撮合方式。
注意：如模拟盘下限价委托单，并且根据盘口撮合后，订单为部分成交，则该订单完整信息在收盘时更新。

2.使用Bar撮合
市价单:

模拟交易

当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销
交易价格: 最新价 + 滑点
最大交易量: 不管是按天, 按分钟, 还是按tick, 由于市价单都是同步完成, 下单那一刻无法知道当天成交量, 所以市价单都不考虑成交量, 全量成交.
所有市价单下单之后同步完成(也即 order_XXX 系列函数返回时完成), context.portfolio 会同步变化

限价单

模拟交易(天、分钟、Tick):

当 委托价 > 最新价+滑点，按市价单模式撮合
当 委托价 <= 最新价+滑点，则挂单，在Bar结束时按照Bar信息进行撮合：
当 委托价 > bar 的最低价，则成交价为委托价，成交量不超过 Bar 成交量 * order_volume_ratio
天、分钟、tick 相同
按tick, 不是立即完成, 而是下单之后每个tick根据这个tick的分价表撮合一次, 直到完全成交或者当天收盘为止. 同样考虑 [order_volume_ratio] 选项.
注意：如模拟盘下限价委托单，订单信息会在收盘后更新。
不是立即完成, 下单之后 context.portfolio.cash 和 context.portfolio.positions 不会同步变化.

按天模拟交易暂时不支持限价单

上述过程中, 如果实际价格已经涨停或者跌停, 则相对应的买单或卖单不成交, 市价单直接取消(log中有警告信息), 限价单会挂单直到可以成交.

一天结束后, 所有未完成的订单会被取消

每次订单完成(完全成交)或者取消后, 我们会根据成交量计算手续费(参见[set_order_cost]), 减少您的现金

更多细节, 请看order函数

拆分合并和分红
传统前复权回测模式：当股票发生拆分，合并或者分红时，股票价格会受到影响，为了保证价格的连续性, 我们使用前复权来处理之前的股票价格，给您的所有股票价格已经是前复权的价格。

真实价格（动态复权）回测模式：当股票发生拆分，合并或者分红时，会按照历史情况，对账户进行处理，会在账户账户中增加现金或持股数量发生变化，并会有日志提示。

注：传统前复权回测模式 与 真实价格（动态复权）回测模式 区别见这里

股息红利税的计算
真实的税率计算方式如下：

分红派息的时候，不扣税；
等你卖出该只股票时，会根据你的股票持有时间（自你买进之日，算到你卖出之日的前一天，下同）超过一年的免税。2015年9月之前的政策是，满一年的收5%。现在执行的是,2015年9月份的新优惠政策：满一年的免税；
等你卖出股票时，你的持有时间在1个月以内（含1个月）的，补交红利的20%税款，券商会在你卖出股票当日清算时直接扣收；
等你卖出股票时，你的持有时间在1个月至1年间（含1年）的，补交红利的10%税款，券商直接扣；
分次买入的股票，一律按照“先进先出”原则，对应计算持股时间；
当日有买进卖出的（即所谓做盘中T+0），收盘后系统计算你当日净额，净额为买入，则记录为今日新买入。净额为卖出，则按照先进先出原则，算成你卖出了你最早买入的对应数量持股，并考虑是否扣税和税率问题。
在回测及模拟交易中，由于需要在分红当天将扣税后的分红现金发放到账户，因此无法准确计算用户的持仓时间（不知道股票卖出时间），我们的计算方式是，统一按照 20% 的税率计算的。

滑点
在实战交易中，往往最终成交价和预期价格有一定偏差，因此我们加入了滑点模式来帮助您更好地模拟真实市场的表现。

交易税费
交易税费包含券商手续费和印花税。您可以通过[set_order_cost]来设置具体的交易税费的参数。

券商手续费
中国A股市场目前为双边收费，券商手续费系默认值为万分之三，即0.03%，最少5元。

印花税
印花税对卖方单边征收，对买方不再征收，系统默认为千分之一，即0.1%。

风险指标
风险指标数据有利于您对策略进行一个客观的评价。

注意: 无论是回测还是模拟, 所有风险指标(年化收益/alpha/beta/sharpe/max_drawdown等指标)都只会每天于17:00左右更新一次, 也只根据每天收盘后的收益计算, 并不考虑每天盘中的收益情况. 例外:

分钟和TICK模拟盘每分钟会更新策略收益和基准收益
按天模拟盘每天开盘后和收盘后会更新策略收益和基准收益
那么可能会造成这种现象: 模拟时收益曲线中有回撤, 但是 max_drawdown 可能为0.

Total Returns（策略收益）
Total Returns=(Pend−Pstart)/Pstart∗100%
Total Returns=(Pend−Pstart)/Pstart∗100%
Pend=策略最终股票和现金的总价值
Pend=策略最终股票和现金的总价值
Pstart=策略开始股票和现金的总价值
Pstart=策略开始股票和现金的总价值
Total Annualized Returns（策略年化收益）
Total Annualized Returns=Rp=((1+P)250n−1)∗100%
Total Annualized Returns=Rp=((1+P)250n−1)∗100%
P=策略收益
P=策略收益
n=策略执行天数
n=策略执行天数
Benchmark Returns（基准收益）
Benchmark Returns=(Mend−Mstart)/Mstart∗100%
Benchmark Returns=(Mend−Mstart)/Mstart∗100%
Mend=基准最终价值
Mend=基准最终价值
Mstart=基准开始价值
Mstart=基准开始价值
Benchmark Annualized Returns（基准年化收益）
Benchmark Annualized Returns=Rm=((1+M)250n−1)∗100%
Benchmark Annualized Returns=Rm=((1+M)250n−1)∗100%
M=基准收益
M=基准收益
n=策略执行天数
n=策略执行天数
Alpha（阿尔法）
投资中面临着系统性风险（即Beta）和非系统性风险（即Alpha），Alpha是投资者获得与市场波动无关的回报。比如投资者获得了15%的回报，其基准获得了10%的回报，那么Alpha或者价值增值的部分就是5%。

Alpha=α=Rp−[Rf+βp(Rm−Rf)]
Alpha=α=Rp−[Rf+βp(Rm−Rf)]
Rp=策略年化收益率
Rp=策略年化收益率
Rm=基准年化收益率
Rm=基准年化收益率
Rf=无风险利率（默认0.04）
Rf=无风险利率（默认0.04）
βp=策略beta值
βp=策略beta值
Alpha值	解释
α>0	策略相对于风险，获得了超额收益
α=0	策略相对于风险，获得了适当收益
α<0	策略相对于风险，获得了较少收益
Beta（贝塔）
表示投资的系统性风险，反映了策略对大盘变化的敏感性。例如一个策略的Beta为1.5，则大盘涨1%的时候，策略可能涨1.5%，反之亦然；如果一个策略的Beta为-1.5，说明大盘涨1%的时候，策略可能跌1.5%，反之亦然。
Beta=βp=Cov(Dp,Dm)Var(Dm)
Beta=βp=Cov(Dp,Dm)Var(Dm)
Dp=策略每日收益
Dp=策略每日收益
Dm=基准每日收益
Dm=基准每日收益
Cov(Dp,Dm)=策略每日收益与基准每日收益的协方差
Cov(Dp,Dm)=策略每日收益与基准每日收益的协方差
Var(Dm)=基准每日收益的方差
Var(Dm)=基准每日收益的方差
Beta值	解释
β<0	投资组合和基准的走向通常反方向，如空头头寸类
β=0	投资组合和基准的走向没有相关性，如固定收益类
0<β<1	投资组合和基准的走向相同，但是比基准的移动幅度更小
β=1	投资组合和基准的走向相同，并且和基准的移动幅度贴近
β>1	投资组合和基准的走向相同，但是比基准的移动幅度更大
Sharpe（夏普比率）
表示每承受一单位总风险，会产生多少的超额报酬，可以同时对策略的收益与风险进行综合考虑。
Sharpe Ratio=Rp−Rfσp
Sharpe Ratio=Rp−Rfσp
Rp=策略年化收益率
Rp=策略年化收益率
Rf=无风险利率（默认0.04）
Rf=无风险利率（默认0.04）
σp=策略收益波动率
σp=策略收益波动率
Sortino（索提诺比率）
表示每承担一单位的下行风险，将会获得多少超额回报。
Sortino Ratio=Rp−Rfσpd
Sortino Ratio=Rp−Rfσpd
Rp=策略年化收益率
Rp=策略年化收益率
Rf=无风险利率（默认0.04）
Rf=无风险利率（默认0.04）
σpd=策略下行波动率
σpd=策略下行波动率
Information Ratio（信息比率）
衡量单位超额风险带来的超额收益。信息比率越大，说明该策略单位跟踪误差所获得的超额收益越高，因此，信息比率较大的策略的表现要优于信息比率较低的基准。合理的投资目标应该是在承担适度风险下，尽可能追求高信息比率。
Information Ratio=Rp−Rmσt
Information Ratio=Rp−Rmσt
Rp=策略年化收益率
Rp=策略年化收益率
Rm=基准年化收益率
Rm=基准年化收益率
σt=策略与基准每日收益差值的年化标准差
σt=策略与基准每日收益差值的年化标准差
Algorithm Volatility（策略波动率）
用来测量策略的风险性，波动越大代表策略风险越高。
Algorithm Volatility=σp=250n−1∑i=1n(rp−rp¯)2‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾⎷
Algorithm Volatility=σp=250n−1∑i=1n(rp−rp¯)2
rp=策略每日收益率
rp=策略每日收益率
rp¯=策略每日收益率的平均值=1n∑i=1nrp
rp¯=策略每日收益率的平均值=1n∑i=1nrp
n=策略执行天数
n=策略执行天数
Benchmark Volatility（基准波动率）
用来测量基准的风险性，波动越大代表基准风险越高。
Benchmark Volatility=σm=250n−1∑i=1n(rm−rm¯)2‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾⎷
Benchmark Volatility=σm=250n−1∑i=1n(rm−rm¯)2
rm=基准每日收益率
rm=基准每日收益率
rm¯=基准每日收益率的平均值=1n∑i=1nrm
rm¯=基准每日收益率的平均值=1n∑i=1nrm
n=基准执行天数
n=基准执行天数
Max Drawdown（最大回撤）
描述策略可能出现的最糟糕的情况，最极端可能的亏损情况。
Max Drawdown=Max(Px−Py)/Px
Max Drawdown=Max(Px−Py)/Px
Px,Py=策略某日股票和现金的总价值，y>x
Px,Py=策略某日股票和现金的总价值，y>x
Downside Risk（下行波动率）
策略收益下行波动率。和普通收益波动率相比，下行标准差区分了好的和坏的波动。
Downside Risk=σpd=250n∑i=1n(rp−rpi¯)2f(t)‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾⎷
Downside Risk=σpd=250n∑i=1n(rp−rpi¯)2f(t)
rp=策略每日收益率
rp=策略每日收益率
rpi¯=策略至第i日平均收益率=1i∑j=1irj
rpi¯=策略至第i日平均收益率=1i∑j=1irj
n=策略执行天数
n=策略执行天数
f(t)=1 if rp<rpi¯
f(t)=1 if rp<rpi¯
f(t)=0 if rp>=rpi¯
f(t)=0 if rp>=rpi¯
胜率(%)
盈利次数在总交易次数中的占比。
胜率=盈利交易次数总交易次数
胜率=盈利交易次数总交易次数
日胜率(%)
策略盈利超过基准盈利的天数在总交易数中的占比。
日胜率=当日策略收益跑赢当日基准收益的天数总交易日数
日胜率=当日策略收益跑赢当日基准收益的天数总交易日数
盈亏比
周期盈利亏损的比例。
盈亏比=总盈利额总亏损额
盈亏比=总盈利额总亏损额
超额收益
由于投资的资产变动是有复利效应的，所以净值的变动是符合几何增长过程的，在这种情况中，最自然的“减法”不是减法，而是除法，所以一个更合理的超额收益算法是:

策略收益+100%基准收益+100%−100%
策略收益+100%基准收益+100%−100%
先看一眼这条线的效果，第一印象就可以发现它和策略线分开了，不是继续黏在一起。

3.png

回到上面的例子，假如在时间T时策略的净值S是基准B的十倍，那么超额收益线就是:

SB−100%=900%
SB−100%=900%
假设在从 T 之后的一年里，策略涨幅 2% 并且基准涨幅 10%，那么，一年之后的超额收益线是:

S∗1.02B∗1.10−100%=1000%∗92.7%−100%=827%
S∗1.02B∗1.10−100%=1000%∗92.7%−100%=827%
低于了之前的 900%，它表明了在这一年里策略跑输了基准。跑输了多少呢？算一下

827%+100%900%+100%=S∗1.02B∗1.10∗BS=1.021.10=92.7%
827%+100%900%+100%=S∗1.02B∗1.10∗BS=1.021.10=92.7%
告诉我们如果我们在时间T的时候用一块钱策略和一块钱基准一起跑（注意这很重要，不是十块钱策略对一块钱基准），那么在一年之后策略的净值只有基准的 92.7%。

使用除法产生的超额收益线上任意两点的数值都可以进行上面的计算，当然这里要展示的并不是教大家如何去算这个数，而是要让大家明白，只要除法版的超额收益线发生了回撤，就说明在这段时间里策略跑输了基准，而只要超额收益上涨了，就说明策略跑赢了基准，我们不需要再改时间重新回测就可以知道这个信息了。

举一个可以看出效果的例子，看下图标为 1 和 2 的部分：

4.png

在 1 的地方，策略和基准都涨了。谁涨的多？看黄线下跌了，所以是基准涨的多。
在 2 的地方策略和基准都跌了。谁跌的多？看黄线又是下跌了，所以是策略跌的多。
在 1 和 2 哪个地方策略输于基准更厉害？在1的地方黄线挖了一个坑，而在 2 的地方黄线下降并不多，所以虽然看起来2的地方策略跌得很厉害，但其实1的那段输于基准更多。
除此之外，我们知道回测在14年7月4号的超额收益指标是 150% 左右，并且在16年6月24号是接近 200%，并且根据这条黄线的形状，我们可以判断出：如果我从14年7月4号开始运行这个策略，它会在很长一段时间里跑输基准，然后在红色竖线的地方追平，最后在16年6月24号的地方净值大于基准；我们甚至不需要知道策略和基准的收益曲线都可以做出这个判断。

对数轴
除法版超额收益线解决了多个时间序列在截面上比对的问题，但是同一序列在不同时间的对比还存在着问题。什么问题呢？就是我们没法看清策略在两个不同时间段的涨跌幅的区别。再回顾之前的一个回测的话，

5.png

要不是图上标出了最大回撤的位置，我们肯定目测不出最大回撤的位置。这是因为08年的时候策略净值还相对小，回撤个80%所损失的钱也不是那么多；而15年的时候净值是之前的几十倍，就算回撤20%损失也比之前回撤80%的损失多，所以在图上根本对比不出来。再者说，基准线呢？根本都看不见了啊。

和之前一样，这是由于策略净值有着复合增长效应，导致净值上很难表现出很多的信息。这里的解决办法就是把竖轴做一个变换，改成对数轴。

在对数轴的图上，策略（或者基准）在时间T时显示的高度是：

log(在时间T的净值)
log(在时间T的净值)
就像我们之前从减法改成用除法一样，对数log可以把乘法变加法，把除法变减法，

log(x∗y)=log(x)+log(y)
log(x∗y)=log(x)+log(y)
log(x/y)=log(x)−log(y)
log(x/y)=log(x)−log(y)
这样，在对数轴的图上，涨跌幅的倍数就不再是乘除关系而是加法关系，这样回测图上就能看出更丰富的信息了。

举例来说，策略在时间T的时候净值是 S，在 T+1 时是 2S，在 T+2 时是 4S，也就是说在每个时间段都翻了一倍。那么在普通轴上我们可以看出 T+1 的净值比 T 的净值高很多，但是 T+2 的净值比 T+1 高出更多，然而哪个是阶段的涨幅更大却很难看出。如果改用对数轴，那么在 T 时对数轴上高度是 log(S)log(S)；在 T+1 时是 log(2S)=log(2)+log(S)log(2S)=log(2)+log(S)；在 T+2 时是 log(4S)=2log(2)+log(S)log(4S)=2log(2)+log(S)。这三个数构成一个等差数列，也就是说在对数轴上它们相互之间的距离是一样的，很容易通过目测看出每个时间段的涨跌幅是一样的。

再举个最大回撤的例子。假设一策略在 08 年高峰时的净值是 S，并且在随后的股灾中回撤 80%，即损失 0.8S；它在 15 年高峰时净值有之前的五十倍，50S，并在股灾中回撤 50%，即 25S。在普通轴上我们根本不可能目测出哪个回撤更大，但如果换到对数轴上，在08年高峰和低点的对数值分别是 log(S)log(S) 和 log(S/5)=log(S)−log(5)log(S/5)=log(S)−log(5)，那么对数轴上的回撤是 log(5)log(5)；在15年高峰和低点的对数值分别是 log(50S)log(50S) 和 log(25S)=log(50S/2)=log(50S)−log(2)log(25S)=log(50S/2)=log(50S)−log(2)，在对数轴上的回撤是 log(2)log(2)。由于 log(5)>log(2)log(5)>log(2)，我们可以很明显地看出 08 年的回撤大于 16 年。

除此之外，策略和基准在同一时间段中的对比也更简单了。假设基准在一段时间里翻了一倍，策略只涨了 50%，那么如果策略净值太大的话我们在普通轴上根本看不出基准有什么变动。在上边我们提到可以根据除法版超额收益的回撤来观测，而另一个方法就是在对数轴上看：在这段时间里基准在对数轴上上升了log(2)log(2) 个单位，而基准只上升了 log(1.5)log(1.5) 个单位，很直观，上升多的那个就是赢了。

6.png

我们把之前的回测放到对数轴上，净值规模造成的问题荡然无存。08 年回撤巨大，在图上清晰可见。相比之下，16 年的股灾（标注 3 的地方）虽然净值损失很多，但是实际上回撤比 08 年温柔很多，同时凭目测可以看出标注2的阴跌部分回撤和 16 年股灾中差不多。

对数轴上的超额收益
对数轴上的超额收益的计算方法为：

log(策略净值/基准净值)=log(策略净值)−log(基准净值)
log(策略净值/基准净值)=log(策略净值)−log(基准净值)
也就是说，普通轴上的除法版超额收益可以很方便地移植到对数轴上，只要取一个 loglog 就好。这条曲线集成了上面说过的所有优点。首先，由于log函数是单调的（x小于y的话就有log(x)小于log(y)），那么只要超额收益线在对数轴上上升或下降，就说明它在普通轴上同样也上升或下降，于是可以看出策略在这段时间里是跑赢还是跑输了大盘。另外，在对数轴上，净值的规模效应也被消除了。举例来说，在时间T的时候策略净值 S，基准净值 B，一年之后变动为 3S 和 2B，再假设在多年后的某个时间点策略和基准的净值分别是 10S 和 B，一年后变成 30S 和 2B。在这两个一年期里都是策略翻两倍基准翻一倍，实际上是一样的涨跌幅。在基准轴上超额收益分别是从 S/B-100% 变到3S/2B-100%以及从 10S/B-100% 变到30S/2B-100%，由于净资产规模的影响，后者在图像上的变动是前者的 10 倍。但是如果改用对数轴，我们看到两个一年期内超额收益的对数分别是从 log(S/B)log(S/B) 变到 log(3/2)+log(S/B)log(3/2)+log(S/B) 以及从 log(10S/B)log(10S/B) 变到 log(3/2)+log(10S/B)log(3/2)+log(10S/B)，都是得到了log(3/2)log(3/2) 的增长，反映了在这两个一年期里，策略相对于大盘的表现是一样的。

如何看一个策略是否有稳定的alpha收益？最直观的方法莫过于看它在对数轴上的超额收益线了，如果那条线是稳定斜向向上的就对了。

7.png

先看这个回测，它有着整体很高的超额收益，但是我们也发现了几个明显的黄线回撤，说明它在这些时段跑输大盘的地方。而下面这个策略虽然收益不如上面的高，但是超额收益高稳定得多，黄线看不出明显回撤说明它基本没有跑输大盘的时候。

8.png

进一步，我们也可以看出这个策略的超额收益都产生于哪些时候。在第一根红线之前超额收益超额收益斜率较大，说明超额收益很高；两根红线的之间的超额收益基本为零；第二根红线之后又开始有了超额收益，但远没有第一个阶段里高。策略什么时候强什么时候弱，哪些时段需要额外的分析研究，或者很多其他的重要信息，都在一条线上一目了然，这是一条不简单的线。

运行时间
开盘前(9:20)运行:

[run_monthly]/[run_weekly]/[run_daily]中指定time='before_open'运行的函数
[before_trading_start]
盘中运行:

[run_monthly]/[run_weekly]/[run_daily]中在指定交易时间执行的函数, 执行时间为这分钟的第一秒. 例如: run_daily(func, '14:50') 会在每天的14:50:00(精确到秒)执行
[handle_data]
按日回测/模拟, 在9:30:00(精确到秒)运行, [data]为昨天的天数据
按分钟回测/模拟, 在每分钟的第一秒运行, 每天执行240次, 不包括11:30和15:00这两分钟, [data]是上一分钟的分钟数据. 例如: 当天第一次执行是在9:30:00, [data]是昨天14:59这一分钟的分钟数据, 当天最后一次执行是在14:59:00, [data]是14:58这一分钟的分钟数据.
收盘后(15:00后半小时内)运行:

[run_monthly]/[run_weekly]/[run_daily]中指定time='after_close'运行的函数
[after_trading_end]
同一个时间点, 总是先运行 run_XXX 指定的函数, 然后是 [before_trading_start], [handle_data] 和 [after_trading_end]

注意:

run_XXX 指定的函数只能有一个参数 [context], [data] 不再提供, 请使用 [history]/[attribute_history] 获取
[initialize] / [before_trading_start] / [after_trading_end] / [handle_data] 都是可选的, 如果不是必须的, 不要实现这些函数, 一个空函数会降低运行速度.
模拟盘注意事项
为了避免以不合理的价格对标的进行下单，模拟盘在下单时会检查开盘（9:25）到下单时刻的累积成交量，若为0则会拒绝，提示：WARNING - 该标的截至到目前成交量为0 ，暂时无法成交。

模拟盘在每天运行结束后会保存状态, 结束进程(相当于休眠). 然后在第二天恢复.

进程结束时会保存这些状态:

用户账户, 持仓

使用 [pickle] 保存 [g] 对象. 注意

g 中以 '__' 开头的变量将被忽略, 不会被保存
g 中不能序列化的变量不会被保存, 重启后会不存在. 如果你写了如下的代码:
def initialize(context):
    g.query = query(valuation)
[g] 将不能被保存, 因为 query() 返回的对象并不能被持久化. 重启后也不会再执行 [initialize], 使用 g.query 将会抛出 AttributeError 异常
正确的做法是, 在 [process_initialize] 中初始化它, 并且名字以 '__' 开头.
def process_initialize(context):
    g.__query = query(valuation)
注意: 涉及到IO(打开的文件, 网络连接, 数据库连接)的对象是不能被序列化的:
query(valuation) : 数据库连接
open("some/path") : 打开的文件
requests.get('') : 网络连接
使用 [pickle] 保存 [context] 对象, 处理方式跟 [g] 一样

为了防止恶意攻击, 序列化之后的状态大小不能超过 30M, 如果超出将在保存状态时运行失败. 当超过 20M 时日志中会有警告提示, 请注意日志.

恢复过程是这样的:

加载策略代码, 因为python是动态语言, 编译即运行, 所以全局的(在函数外写的)代码会被执行一遍.
使用保存的状态恢复 [g], [context], 和函数外定义的全局变量.
如果策略代码和上一次运行时发生了修改，而且代码中定义了 [after_code_changed] 函数，则会运行 [after_code_changed] 函数。
执行 [process_initialize], 每次启动时都会执行这个函数.
重启后不再执行 [initialize] 函数, [initialize] 函数在整个模拟盘的生命周期中只执行一次. 即使是更改回测后, [initialize] 也不会执行.

模拟盘更改回测之后上述的全局变量(包括 g 和 context 中保存的)不会丢失. 新代码中 [initialize] 不会执行. 如果需要修改原来的值, 可以在 [after_code_changed] 函数里面修改, 比如, 原来代码是:

a = 1
def initialize(context):
    g.stock = '000001.XSHE'
代码改成:

a = 2
def initialize(context):
    g.stock = '000002.XSHE'
执行时, a 仍然是 1, g.stock 仍然是 '000001.XSHE', 要修改他们的值, 必须定义 [after_code_changed]:

def after_code_changed(context):
    global a
    a = 2
    g.stock = '000002.XSHE'
创建模拟交易时, 如果选择的日期是今天, 则从今天当前时间点开始运行, 应该在当前时间点之前运行的函数不再运行. 比如: 今天10:00创建了按天的模拟交易, 选择日期是今天, 代码中实现了 handle_data 和 after_trading_end, 则 handle_data 今天不运行, 而 after_trading_end 会在 15:10 运行

当模拟交易在A时间点失败后, 然后在B时间点"重跑", 那么 A-B 之间的时间点应该运行的函数不再运行

因为模拟盘资源有限, 为了防止用户创建之后长期搁置浪费资源, 我们仅为至少满足以下条件之一的用户运行模拟交易：

模拟盘所有者在最近一个月内访问过聚宽网站
用户的策略在策略擂台/策略商城上
用户的策略被其他用户购买的
当用户重新使用网站后, 第二天会继续运行(会把之前的交易日执行一遍, 并不会跳过日期)

强烈建议模拟盘使用真实价格成交, 即调用 set_option('use_real_price', True).
模拟交易和回测的差别
因为一些原因, 模拟交易现在和回测还是有些微小的差别, 具体如下:

市价单的处理:

回测: 成交量不会超过当天成交量(或当天成交量的一部分, 见[order_volume_ratio] 选项)
模拟: 默认使用盘口撮合，五档之后转撤销处理；关闭盘口撮合后，如果成交量不为0，则全部成交。
这会导致同样的日期同样的程序回测结果可能会和模拟交易结果不一样, 请注意

按天模拟交易暂时不支持限价单, 所有限价单会自动转成市价单

理论上对运行结果不会有影响: 模拟交易进程每天会重启(请看[模拟交易注意事项]). 回测进程一般不会重启, 如果需要重启(比如机器宕机了) 也会做和模拟交易同样的处理.

期货交割日
期货持仓到交割日，没有手动交割，系统会以当天结算价平仓, 没有手续费, 不会有交易记录.

还券细则
T+1, 当日融的券当日不能还
还券时要扣除利息
直接还券时, 可以使用当日买入的券还(不受T+1限制), 且优先使用当日买入的券还
投资组合优化器
投资组合优化是指应用概率论与数理统计、最优化方法以及线性代数等相关数学理论方法，根据既定目标收益和风险容许程度（例如最大化收益，最小化风险，风险平价等），将投资重新组合，分散风险的过程，它体现了投资者的意愿和投资者所受到的约束，即在一定风险水平下收益最大化或一定收益水平下的风险最小化。

投资组合管理者在设定了投资收益预期、风险预算、相关约束和风险模型之后， 依托优化器的快速计算优势，得到资产配置最优化结果。

由于不同的约束条件、目标函数，会形成不同的优化器，优化器的处理结果依赖用户输入的相关信息，因此投资者对收益率的预期和风险模型本身估计的准确性，都会影响最终的分析结果，再考虑到交易成本等各类因素的影响，所以从用户使用上而言， 没有绝对意义上最好的优化器。对于资产组合优化问题， 我们可以通过使用优化器，进行一个较长时间的回测，测试整个投资过程，在所有组合输入一致的情况下通过策略的绩效对比来看哪一个优化器有更好的表现， 或者更符合自己的需求。

组合优化器支持对股票、基金进行投资优化，支持如下优化模型：

MinVariance - 组合风险最小化（均值-方差优化）
MaxProfit - 组合收益最大化
MaxSharpeRatio - 组合夏普比率最大化
MinTrackingError - 追踪误差最小化
RiskParity - 风险平价
MaxScore - 组合标的打分最大化
MinScore - 组合标的打分最小化
MaxFactorValue - 因子值最大化
MinFactorValue - 因子值最小化
自定义约束条件的优化模型
对使用优化器的投资组合管理者来说，只需根据收益预期、风险预算，选择恰当的优化模型，并设定相关的约束限制条件。优化器程序可以基于选定的优化模型，输出优化后的投资权重调整建议。我们会对投资组合优化器的进行持续创新与改进。

示例
下面选出上证50成分股的一部分与选定的ETF基金进行组合构成股票池，设定不同的投资组合优化约束条件，并进行回测，测试投资组合优化器对整个投资的影响。

模型1：等权重配置
enter image description here

模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%
enter image description here

模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%
enter image description here

模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%
enter image description here

模型5：组合夏普比率最大化；每只标的权重不超过10%
enter image description here

回测代码如下, 优化函数API详情见 portfolio_optimizer - 投资组合优化：

# 导入函数库
import pandas as pd
from jqdata import *
from jqfactor import Factor
from jqlib.optimizer import *

# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)

    # 过滤掉order系列API产生的比error级别低的log
    log.set_level('order', 'error')

    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003,
                            min_commission=5), type='stock')

    # 优化器设置
    g.optimizer = 2 #设定使用的优化模型
    optimize_model = {
                        1:"模型1：等权重配置",
                        2:"模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%",
                        3:"模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%",
                        4:"模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%",
                        5:"模型5：组合夏普比率最大化；每只标的权重不超过10%"
                      }
    print("优化%s"%(optimize_model[g.optimizer]))

    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_monthly(before_market_open, monthday=1, time='before_open', reference_security='000300.XSHG')
      # 开盘运行
    run_monthly(market_open, monthday=1, time='open', reference_security='000300.XSHG')

## 开盘前运行函数
def before_market_open(context):
    print('调仓日期：%s'%context.current_dt.date())

    # 选出上证50成分股的一部分与选定的ETF基金进行组合,构成股票池。
    etf = [
        '159902.XSHE',
        '159903.XSHE',
        '510050.XSHG',
        '510880.XSHG',
        '510440.XSHG',
        ]
    g.buy_list = list(get_index_stocks('000016.XSHG')[-15:]) + etf

## 开盘时运行函数
def market_open(context):
    # 讲不在股票池中的股票卖出
    sell_list = set(context.portfolio.positions.keys()) - set(g.buy_list)
    for stock in sell_list:
        order_target_value(stock, 0)

    # 组合优化模型
    if g.optimizer == 1:
        # 模型1：等权重配置
        optimized_weight = pd.Series(data=[1.0/len(g.buy_list)]*len(g.buy_list),
                                    index=g.buy_list)
    elif g.optimizer == 2:
        # 模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%
        optimized_weight = portfolio_optimizer(date=context.previous_date,
                                    securities = g.buy_list,
                                    target = RiskParity(count=250, risk_budget=None),# risk_budget 为 None默认为每只股票贡献相等
                                    constraints = [MarketConstraint('stock', low=0.0, high=0.9),
                                                  MarketConstraint('etf', low=0.0, high=0.1)],
                                    bounds=[Bound(0, 0.1)],
                                    default_port_weight_range=[0., 1.0],
                                    ftol=1e-09,
                                    return_none_if_fail=True)
    elif g.optimizer == 3:
        # 模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%
        optimized_weight = portfolio_optimizer(date=context.previous_date,
                                    securities = g.buy_list,
                                    target = MinVariance(count=250),
                                    constraints = [WeightConstraint(low=0.9, high=1.0),
                                                   AnnualProfitConstraint(limit=0.1, count=250)],
                                    bounds=[],
                                    default_port_weight_range=[0., 1.0],
                                    ftol=1e-09,
                                    return_none_if_fail=True)
    elif g.optimizer == 4:
        # 模型4：组合标的因子值最大化

        # 定义因子：人气指标5日均值
        class AR(Factor):
            name = 'ar'
            # 每天获取过去五日的数据
            max_window = 5
            # 获取的数据是人气指标
            dependencies = ['AR']
            def calc(self, data):
                return data['AR'].mean()
        # 模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%
        optimized_weight = portfolio_optimizer(date=context.previous_date,
                                    securities = g.buy_list,
                                    target = MaxFactorValue(factor=AR, count=1),
                                    constraints = [AnnualProfitConstraint(limit=0.2, count=250)],
                                    bounds=[Bound(0, 0.2)],
                                    default_port_weight_range=[0., 1.0],
                                    ftol=1e-09,
                                    return_none_if_fail=True)
    elif g.optimizer == 5:
        # 模型5：组合夏普比率最大化；每只标的权重不超过10%
        optimized_weight = portfolio_optimizer(date=context.previous_date,
                                    securities = g.buy_list,
                                    target = MaxSharpeRatio(rf=0.0,weight_sum_equal=0.5, count=250),#无风险利率为0，最大化夏普比率需要约束组合权重的和为0.5
                                    constraints = [],
                                    bounds=[Bound(0, 0.1)],
                                    default_port_weight_range=[0., 1.0],
                                    ftol=1e-09,
                                    return_none_if_fail=True)

    # 查看优化结果
    print(optimized_weight)

    # 优化失败，给予警告
    if type(optimized_weight) == type(None):
        print('警告：组合优化失败')
    # 按优化结果，执行调仓操作
    else:
        total_value = context.portfolio.total_value # 获取总资产
        for stock in optimized_weight.keys():
            value = total_value * optimized_weight[stock] # 确定每个标的的权重
            order_target_value(stock, value) # 调整标的至目标权重
API介绍
注意事项
【取数据函数】【其它函数】目录中带有"♠" 标识的API是 "回测环境/模拟"专用的API，不能在研究模块中调用。整个 【jqdata 模块】在研究环境与回测环境下都可以使用.
所有价格单位是元
时间表示:
所有时间都是北京时间, 时区:UTC+8
所有时间都是[datetime.datetime]对象
每个交易日结束时自动撤销所有未完成订单， 例如A股是在17:00之后。
下文中提到 Context, SecurityUnitData, Portfolio, Position, Order 对象都是只读的, 尝试修改他们会报错或者无效.
没有python基础的同学请注意, 有的函数的定义中, 某些参数是有值的, 这个值是参数的默认值, 这个参数是可选的, 可以不传.
回测和模拟中，每日下单的最大数量为10000笔
如需使用分仓操作，请看账户分仓操作.

策略设置函数
set_benchmark - 设置基准
disable_cache()
在默认情况下系统启用了缓存以加快运行速度，但在策略内存占用较大时容易超过设置的内存上限而触发系统杀死进程。若用户反复出现策略因内存占用超限而被终止的情况，可以考虑在initialize函数中调用disable_cache来关闭缓存机制。注意在关闭缓存后会导致策略运行速度明显下降。

set_order_cost - 设置佣金/印花税
set_order_cost(cost, type, ref=None)
指定每笔交易要收取的手续费, 系统会根据用户指定的费率计算每笔交易的手续费

参数

cost: OrderCost 对象
open_tax，买入时印花税 (只股票类标的收取，基金与期货不收)
close_tax，卖出时印花税 (只股票类标的收取，基金与期货不收)
open_commission，买入时佣金，申购场外基金的手续费
close_commission, 卖出时佣金，赎回场外基金的手续费
close_today_commission, 平今仓佣金
min_commission, 最低佣金，不包含印花税
参数

type：交易品种，支持股票、场内基金、场内交易的货币基金、金融期货、期货、债券基金、股票基金、QDII 基金、货币基金、混合基金，'stock'/ 'fund' / 'mmf'（场内交易的货币基金）/'index_futures' （金融期货）/ 'futures'（包含股指期货和商品期货） / 'bond_fund' / 'stock_fund' / 'QDII_fund' / 'money_market_fund' / ‘mixture_fund' 。为None时则应用于全局。当type被设定而ref为None时，表示将滑点应用于交易品种为type的所有交易标的。

ref: 参考代码，支持股票代码/基金代码/期货合约代码，以及期货的品种，如 '000001.XSHE'/'510180.XSHG'/'IF1709'/'IF'/'000300.OF'

注意：针对特定的交易品种类别设置手续费时，必须将ref设为None；若针对特定的交易品种或者标的，需要将type设置为对应的交易品种类别，将ref设置为对应的交易品种或者标的

默认与示例

# 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock')

# 期货类每笔交易时的手续费是：买入时万分之0.23,卖出时万分之0.23,平今仓为万分之23
set_order_cost(OrderCost(open_tax=0, close_tax=0, open_commission=0.000023, close_commission=0.000023, close_today_commission=0.0023, min_commission=0), type='index_futures')

# 单独设置 000300.XSHG 的费用
set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock', ref='000300.XSHG')

# 设置所有期货（包括金融指数期货）的费用
set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures')

# 对 IF/IH/IC 三个品种有效
set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='index_futures')

# 单独设置AU期货品种的费用
set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures', ref='AU')

# 单独设置AU1709合约的费用
set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures', ref='AU1709')
注：期货持仓到交割日会以当天结算价平仓, 没有手续费, 不会有交易记录.

set_slippage - 设置滑点
set_slippage(object,type=None, ref=None)
设定滑点，回测/模拟时有效.

当您下单后, 真实的成交价格与下单时预期的价格总会有一定偏差, 因此我们加入了滑点模式来帮您更好的模拟真实市场的表现. 我们暂时只支持固定滑点。同时，我们也支持为交易品种和特定的交易标的设置滑点。

参数

type：交易品种，支持股票、基金、金融期货、期货、债券基金、股票基金、QDII 基金、货币基金、混合基金，'stock'/ 'fund' / 'index_futures' （金融期货）/ 'futures'（包含股指期货和商品期货） / 'bond_fund' / 'stock_fund' / 'QDII_fund' / 'money_market_fund' / ‘mixture_fund' 。为None时则应用于全局。当type被设定而ref为None时，表示将滑点应用于
ref: 标的代码。如要为特定交易标的单独设置滑点，必须同时设置type为交易标的的交易品种。
固定滑点 当您使用固定滑点的时候, 我们认为您的落单的多少并不会影响您最后的成交价格. 您只需要指定一个价差, 当您下达一个买单指令的时候, 成交的价格等于当时(您执行order函数所在的单位时间)的平均价格加上价差的一半；当您下达一个卖出指令的时候，卖出的价格等于当时的平均价格减去价差的一半. 价差可以设定为一个固定值或者按照百分比设定。

固定值： 这个价差可以是一个固定的值(比如0.02元, 交易时加减0.01元), 设定方式为：FixedSlippage(0.02)
百分比： 这个价差可以是是当时价格的一个百分比(比如0.2%, 交易时加减当时价格的0.1%), 设定方式为：PriceRelatedSlippage(0.002)
跳数（期货专用）: 这个价差可以是合约的价格变动单位（跳数），比如0.02跳，设定方式为： StepRelatedSlippage(0.02)
# 为全部交易品种设定固定值滑点
set_slippage(FixedSlippage(0.02))

# 为股票设定滑点为百分比滑点
set_slippage(PriceRelatedSlippage(0.00246),type='stock')

# 为CU1809设定滑点为跳数滑点
set_slippage(StepRelatedSlippage(0.02),type='future', ref="CU1809.XSGE")
注：如果您没有调用 set_slippage 函数, 系统默认的滑点是 PriceRelatedSlippage(0.00246)

设置动态复权(真实价格)模式
set_option('use_real_price', value)
该设定必须在[initialize]中调用 设置是否开启动态复权（真实价格）模式，原理讲解图示见帖子。默认是False(主要是为了让旧的策略不会出错). 是否开启动态复权模式对模拟交易是有影响的，详情参见这里。

在场外基金中的应用

1）value=True，表示用基金的单位净值进行撮合成交
2）value=False，表示分红再投资，即复权净值进行撮合成交

参数

value: True / False
示例

# 开启动态复权模式
set_option('use_real_price', True)
是否开启动态复权对于回测及模拟交易的影响：

动态复权原理
是否开启动态复权模式对模拟交易的影响
开启，value 值为 True: 回测过程中:

每天看到的当天的价格都是真实的(不复权的)

使用真实的价格下单, 交易详情和持仓详情里看到的都是真实价格

为了让编写代码简单, 通过[history]/[attribute_history]/[get_price]/[SecurityUnitData].mavg/vwap 等API 拿到的都是基于当天日期的前复权价格. 比如: 回测运行到了2015-01-01这一天, 那么history(3, '1d', 'close')取得的就是你穿越到2015-01-01这一天所看到的前复权价格. 另一方面, 你在不同日期调用 [history]/[attribute_history]/[get_price]/[SecurityUnitData].mavg/vwap 返回的价格可能是不一样的, 因为我们在不同日期看到的前复权价格是不一样的. 所以不要跨日期缓存这些API返回的结果.

每到新的一天, 如果持仓中有股票发生了拆合或者分红或者其他可能影响复权因子的情形, 我们会根据复权因子自动调整股票的数量, 如果调整后的数量是小数, 则向下取整到整数, 最后为了保证[context].portfolio.portfolio_value不变, [context].portfolio.cash可能有略微调整.

注意事项:

如上所说, 不要跨日期缓存[history]/[attribute_history]/[get_price]这些API返回的结果

开启真实价格回测之后, 回测结果可能会之前不一样, 因为交易时买入数量必须是100的倍数, 使用前复权价格和实际价格能买入的数量是不一样的.

如果想通过 history 拿到昨天的真实价格, 还是需要用取得价格除以factor, 因为可能今天发生了拆合分红, 导致拿到的昨天的价格是相对于今天的前复权价格.

s = '000001.XSHE'
df = attribute_history(s, 1, '1d', fields=['close', 'factor'])
real_close = df['close'][-1] / df['factor'][-1]
关闭，value 值为 False: 此选项的核心是选定一个日期作为基准, 保证这个日期的价格是真实价格, 然后调整其他日期的价格. 最终保证所有价格是连续的, 在回测或者模拟交易过程中不同日期看到的价格是一致的. 下面分回测和模拟交易单独做介绍:

回测: 基准日期是建立回测的日期, 回测过程中所看到的所有价格都是基于此日期的前复权价格. 比如说, 我昨天跑了一个回测, 那么回测过程所有价格都是在昨天所看到的前复权价格. 这会导致两个问题:
回测过程中使用了前复权价格下单, 这是违背真实场景的, 不能对接实盘的.
不同的日期建立的回测跑出来的结果可能会有差异, 因为如果这两次回测之间回测的股票发生了拆合或者分红, 会导致回测中看到前复权价格会不一致.
模拟交易: 基准日期是建立模拟交易的日期, 模拟交易过程所看到的所有价格都是基于此日期调整过的. 为了方便计算, 我举一个虚拟的例子: 某只股票在如下三个日期的实际价格和后复权因子分别是:
日期	价格	后复权因子
2015-09-01	1	1
2015-10-01	2	2
2015-11-01	4	4
如果你在 09-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 1

如果你在 10-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 2

如果你在 11-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 4

为了更好的模拟, 建议大家都设成 True. 将来对接实盘交易时, 此选项会强制设成 True

注意： 设置 use_real_price 为 True之后, 如下的按天回测的代码是不对的：

def initialize(context):
    g.cached_data = []
    g.s = '000001.XSHE'

def handle_data(content, data):
    g.cached_data.append(data)
    if len(g.cached_data) > 1:
        # 如果昨天收盘价比前天涨了5%, 则买入. 这是不对的, 如果昨天早上发生了拆合, 则昨天和前天的股价不具可比性.
        if g.cached_data[-1][g.s].close > g.cached_data[-2][g.s].close * 1.05:
            order(g.s, 1000)
设置成交量比例
set_option('order_volume_ratio', value)
设定成交量比例，根据实际行情限制每个订单的成交量.

参数

value: value 是一个 float 值, 默认为0.25, 根据实际行情限制每个订单的成交量.

对于每一笔订单：

如果是市价单, 成交量不超过: 每日成交量 * value

如果是限价单, 限价单撮合时设定分价表中每一个价格的成交量的比率, 假设某一分钟分价表如下:

价格	成交量
10.0	10
10.1	11
10.2	12
撮合时, 按价格 10.0 成交 10 * value 股, 按价格 10.1 成交 11 * value 股, 按价格 10.2 成交 12 * value 股

示例

# 设定成交量比例
set_option('order_volume_ratio', 0.25) # 成交量不超过总成交量的四分之一
设置是否开启盘口撮合模式
set_option('match_with_order_book', value)
设定是否使用盘口撮合模式. 此选项只对模拟盘生效，默认开启

参数

value: 默认开启
True，开启，使用盘口进行撮合，撮合方式详见[订单处理]
False，关闭，使用 Bar 进行撮合，撮合方式详见[订单处理]
set_universe(history专用)
set_universe(security_list)
设置或者更新此策略要操作的股票池 context.universe. 请注意:

该函数现在只用于设定history函数的默认security_list, 除此之外并无其他用处。
参数

security_list: 股票列表
返回 None

示例

set_universe(['000001.XSHE', '600000.XSHG'])
set_commission(已废弃)
set_commission(object)
已废弃。请使用set_order_cost替代

指定每笔交易要收取的手续费, 系统会根据用户指定的费率计算每笔交易的手续费

次函数已废弃，请使用 set_order_cost - 设置佣金/印花税

参数 object: 一个PerTrade对象

PerTrade.buy_cost，买入时手续费
PerTrade.sell_cost，卖出时手续费
PerTrade.min_cost，最少的手续费
默认：PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5) 每笔交易时的手续费是, 买入时万分之三，卖出时万分之三加千分之一印花税, 每笔交易最低扣5块钱

disable_cache - 关闭缓存
disable_cache()
在默认情况下系统启用了缓存以加快运行速度，但在策略内存占用较大时容易超过设置的内存上限而触发系统杀死进程。若用户反复出现策略因内存占用超限而被终止的情况，可以考虑在initialize函数中调用disable_cache来关闭缓存机制。

注意在关闭缓存后会导致策略运行速度明显下降。

获取数据函数
get_price - 获取历史数据
get_price(security, start_date=None, end_date=None, frequency='daily', fields=None, skip_paused=False, fq='pre', count=None)
获取一支或者多只股票的行情数据, 按天或者按分钟，这里在使用时注意 end_date 的设置， 不要引入未来的数据。

关于停牌: 因为此API可以获取多只股票的数据, 可能有的股票停牌有的没有, 为了保持时间轴的一致,

我们默认没有跳过停牌的日期, 停牌时使用停牌前的数据填充(请看 [SecurityUnitData] 的 paused 属性). 如想跳过, 请使用 skip_paused=True 参数, 同时只取一只股票的信息

参数

security: 一支股票代码或者一个股票代码的list

count: 与 start_date 二选一，不可同时使用. 数量, 返回的结果集的行数, 即表示获取 end_date 之前几个 frequency 的数据

start_date: 与 count 二选一，不可同时使用. 字符串或者 [datetime.datetime]/[datetime.date] 对象, 开始时间.

如果 count 和 start_date 参数都没有, 则 start_date 生效, 值是 '2015-01-01'. 注意:
当取分钟数据时, 时间可以精确到分钟, 比如: 传入 datetime.datetime(2015, 1, 1, 10, 0, 0) 或者 '2015-01-01 10:00:00'.
当取分钟数据时, 如果只传入日期, 则日内时间是当日的 00:00:00.
当取天数据时, 传入的日内时间会被忽略
end_date: 格式同上, 结束时间, 默认是'2015-12-31', 包含此日期. 注意: 当取分钟数据时, 如果 end_date 只有日期, 则日内时间等同于 00:00:00, 所以返回的数据是不包括 end_date 这一天的.

frequency: 单位时间长度, 几天或者几分钟, 现在支持'Xd','Xm', 'daily'(等同于'1d'), 'minute'(等同于'1m'), X是一个正整数, 分别表示X天和X分钟(不论是按天还是按分钟回测都能拿到这两种单位的数据), 注意, 当X > 1时, fields只支持['open', 'close', 'high', 'low', 'volume', 'money']这几个标准字段,合成数据的逻辑见下文. 默认值是daily

fields: 字符串list, 选择要获取的行情数据字段, 默认是None(表示['open', 'close', 'high', 'low', 'volume', 'money']这几个标准字段), 支持SecurityUnitData里面的所有基本属性,，包含：['open', ' close', 'low', 'high', 'volume', 'money', 'factor', 'high_limit',' low_limit', 'avg', ' pre_close', 'paused']

skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停牌前的数据填充(具体请看SecurityUnitData的paused属性), 上市前或者退市后数据都为 nan, 但要注意:

默认为 False
当 skip_paused 是 True 时, 只能取一只股票的信息
fq: 复权选项:

'pre': 前复权(根据'use_real_price'选项不同含义会有所不同, 参见[set_option]), 默认是前复权
None: 不复权, 返回实际价格
'post': 后复权
合成数据的逻辑 当frequency为X天和X分钟时，代表使用以X为长度的滑动窗口进行合并数据。举例：

9:33:00调用get_price获取1个单位的数据，frequency='5min',表示使用上一交易日14:58、14:59、15:00、本交易日9:31、9:32这5根1分钟K线来合成数据；

9:37:00调用get_price获取1个单位的数据，frequency='5min',表示使用本交易日9:32、9:33、9:34、9:35、9:36这5根1分钟K线来合成数据；

返回

请注意, 为了方便比较一只股票的多个属性, 同时也满足对比多只股票的一个属性的需求, 我们在security参数是一只股票和多只股票时返回的结构完全不一样

如果是一支股票, 则返回[pandas.DataFrame]对象, 行索引是[datetime.datetime]对象, 列索引是行情字段名字, 比如'open'/'close'. 比如: get_price('000300.XSHG')[:2] 返回:

---	open	close	high	low	volume	money
2015-01-05 00:00:00	3566.09	3641.54	3669.04	3551.51	451198098.0	519849817448.0
2015-01-06 00:00:00	3608.43	3641.06	3683.23	3587.23	420962185.0	498529588258.0
如果是多支股票, 则返回[pandas.Panel]对象, 里面是很多[pandas.DataFrame]对象, 索引是行情字段(open/close/…), 每个[pandas.DataFrame]的行索引是[datetime.datetime]对象, 列索引是股票代号. 比如get_price(['000300.XSHG', '000001.XSHE'])['open'][:2]返回:
---	000300.XSHG	000001.XSHE
2015-01-05 00:00:00	3566.09	13.21
2015-01-06 00:00:00	3608.43	13.09
取多支标的的数据时，不要获取交易时段不同的标的，否则会报错。
示例

# 获取一支股票
df = get_price('000001.XSHE') # 获取000001.XSHE的2015年的按天数据
df = get_price('000001.XSHE', start_date='2015-01-01', end_date='2015-01-31 23:00:00', frequency='minute', fields=['open', 'close']) # 获得000001.XSHG的2015年01月的分钟数据, 只获取open+close字段
df = get_price('000001.XSHE', count = 2, end_date='2015-01-31', frequency='daily', fields=['open', 'close']) # 获取获得000001.XSHG在2015年01月31日前2个交易日的数据
df = get_price('000001.XSHE', start_date='2015-12-01 14:00:00', end_date='2015-12-02 12:00:00', frequency='1m') # 获得000001.XSHG的2015年12月1号14:00-2015年12月2日12:00的分钟数据

# 获取多只股票
panel =  get_price(get_index_stocks('000903.XSHG')) # 获取中证100的所有成分股的2015年的天数据, 返回一个[pandas.Panel]
df_open = panel['open']  # 获取开盘价的[pandas.DataFrame],  行索引是[datetime.datetime]对象, 列索引是股票代号
df_volume = panel['volume']  # 获取交易量的[pandas.DataFrame]

df_open['000001.XSHE'] # 获取平安银行的2015年每天的开盘价数据
history ♠ - 获取历史数据
history(count, unit='1d', field='avg', security_list=None, df=True, skip_paused=False, fq='pre')
回测环境/模拟专用API

查看历史的行情数据。

关于停牌: 因为获取了多只股票的数据, 可能有的股票停牌有的没有, 为了保持时间轴的一致, 我们默认没有跳过停牌的日期, 停牌时使用停牌前的数据填充(请看[SecurityUnitData]的paused属性). 如想跳过, 请使用 skip_paused=True 参数

当取天数据时, 不包括当天的, 即使是在收盘后

参数

count: 数量, 返回的结果集的行数

unit: 单位时间长度, 几天或者几分钟, 现在支持'Xd','Xm', X是一个正整数, 分别表示X天和X分钟(不论是按天还是按分钟回测都能拿到这两种单位的数据), 注意, 当X > 1时, field只支持['open', 'close', 'high', 'low', 'volume', 'money']这几个标准字段.

field: 要获取的数据类型, 支持SecurityUnitData里面的所有基本属性,，包含：['open', ' close', 'low', 'high', 'volume', 'money', 'factor', 'high_limit',' low_limit', 'avg', ' pre_close', 'paused']

security_list:

要获取数据的股票列表
None 表示查询 context.universe 中所有股票的数据，context.universe 需要使用set_universe进行设定，形如：set_universe(['000001.XSHE', '600000.XSHG'])。
df: 若是True, 返回[pandas.DataFrame], 否则返回一个dict, 具体请看下面的返回值介绍. 默认是True. 我们之所以增加df参数, 是因为[pandas.DataFrame]创建和操作速度太慢, 很多情况并不需要使用它. 为了保持向上兼容, df默认是True, 但是如果你的回测速度很慢, 请考虑把df设成False.

skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停牌前的数据填充(具体请看SecurityUnitData的paused属性), 上市前或者退市后数据都为 nan, 但要注意:

默认为 False
如果跳过, 则行索引不再是日期, 因为不同股票的实际交易日期可能不一样
fq: 复权选项:

'pre': 前复权(根据'use_real_price'选项不同含义会有所不同, 参见[set_option]), 默认是前复权
None: 不复权, 返回实际价格
'post': 后复权
返回

df=True: [pandas.DataFrame]对象, 行索引是[datetime.datetime]对象, 列索引是股票代号. 比如: 如果当前时间是2015-01-07, universe是['000300.XSHG', '000001.XSHE'], history(2, '1d', 'open')将返回:
---	000300.XSHG	000001.XSHE
2015-01-05 00:00:00	3566.09	13.21
2015-01-06 00:00:00	3608.43	13.09
关于numpy和pandas, 请看下面的第三方库介绍

df=False: dict, key是股票代码, 值是一个numpy数组[numpy.ndarray], 对应上面的DataFrame的每一列, 例如history(2, '1d', 'open', df=False)将返回: python { '000300.XSHG': array([ 3566.09, 3608.43]), '000001.XSHE': array([ 13.21, 13.09]) }
示例

h = history(5, security_list=['000001.XSHE', '000002.XSHE'])
h['000001.XSHE'] #000001(平安银行)过去5天的每天的平均价, 一个pd.Series对象, index是datatime
h['000001.XSHE'][-1] #000001(平安银行)昨天(数组最后一项)的平均价
h.iloc[-1] #所有股票在昨天的平均价, 一个pd.Series对象, index是股票代号
h.iloc[-1]['000001.XSHE'] #000001(平安银行)昨天(数组最后一项)的平均价
h.mean() # 取得每一列的平均值
## set_universe 之后可以，调用 history 可以不用指定 security_list
set_universe(['000001.XSHE']) # 设定universe
history(5) # 获取universe中股票的过去5天(不包含今天)的每天的平均价
history(5, '1m') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟的平均价
history(5, '1m', 'price') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟的平均价
history(5, '1m', 'volume') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟的交易额
history(5, '1m', 'price', ['000001.XSHE']) # 获取平安银行的过去5分钟(不包含当前分钟)的每分钟的平均价
h = history(5, security_list=['000001.XSHE', '000002.XSHE'], df=False)
h['000001.XSHE'] #h 是一个 dict，获取 h 中 000001.XSHE 对应的值。
h['000001.XSHE'][0] #返回000001.XSHE最新一日的数据
h['000001.XSHE'][-1] #返回000001.XSHE第五天的数据
h['000001.XSHE'].sum() #对返回的五日数据求和
h['000001.XSHE'].mean() # 对返回的五日数据求平均
# 因为h本身是一个dict, 下列panda.DataFrame的特性将不可用:
# h.illoc[-1]
# h.sum()
attribute_history ♠ - 获取历史数据
attribute_history(security, count, unit='1d',
            fields=['open', 'close', 'high', 'low', 'volume', 'money'],
            skip_paused=True, df=True, fq='pre')
回测环境/模拟专用API

查看某一支股票的历史数据, 可以选这只股票的多个属性, 默认跳过停牌日期.

当取天数据时, 不包括当天的, 即使是在收盘后

参数

security: 股票代码

count: 数量, 返回的结果集的行数

unit: 单位时间长度, 几天或者几分钟, 现在支持 'Xd', 'Xm', X是一个正整数, 分别表示X天和X分钟(不论是按天还是按分钟回测都能拿到这两种单位的数据), 注意, 当 X > 1 时, field 只支持 ['open', 'close', 'high', 'low', 'volume', 'money'] 这几个标准字段.

fields: 股票属性的list, 支持SecurityUnitData里面的所有基本属性，包含：['open', ' close', 'low', 'high', 'volume', 'money', 'factor', 'high_limit',' low_limit', 'avg', ' pre_close', 'paused']

skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停牌前的数据填充(具体请看[SecurityUnitData]的paused属性), 上市前或者退市后数据都为 nan, 默认是True

df: 若是True, 返回[pandas.DataFrame], 否则返回一个dict, 具体请看下面的返回值介绍. 默认是True.我们之所以增加df参数, 是因为[pandas.DataFrame]创建和操作速度太慢, 很多情况并不需要使用它. 为了保持向上兼容, df默认是True, 但是如果你的回测速度很慢, 请考虑把df设成False.

fq: 复权选项:

'pre': 前复权(根据'use_real_price'选项不同含义会有所不同, 参见[set_option]), 默认是前复权
None: 不复权, 返回实际价格
'post': 后复权
返回

df=True [pandas.DataFrame]对象, 行索引是[datetime.datetime]对象, 列索引是属性名字. 比如: 如果当前时间是2015-01-07, attribute_history('000300.XSHG', 2)将返回:
---	open	close	high	low	volume	money
2015-01-05 00:00:00	3566.09	3641.54	3669.04	3551.51	451198098.0	519849817448.0
2015-01-06 00:00:00	3608.43	3641.06	3683.23	3587.23	420962185.0	498529588258.0
df=False: dict, key是股票代码, 值是一个numpy数组[numpy.ndarray], 对应上面的DataFrame的每一列, 例如attribute_history('000300.XSHG', 2, df=False)将返回: python { 'volume': array([ 4.51198098e+08, 4.20962185e+08]), 'money': array([ 5.19849817e+11, 4.98529588e+11]), 'high': array([ 3669.04, 3683.23]), 'low': array([ 3551.51, 3587.23]), 'close': array([ 3641.54, 3641.06]), 'open': array([ 3566.09, 3608.43]) }
示例

stock = '000001.XSHE'
h = attribute_history(stock, 5, '1d', ('open','close', 'volume', 'factor')) # 取得000001(平安银行)过去5天的每天的开盘价, 收盘价, 交易量, 复权因子
# 不管df等于True还是False, 下列用法都是可以的
h['open'] #过去5天的每天的开盘价, 一个pd.Series对象, index是datatime
h['close'][-1] #昨天的收盘价
h['open'].mean()

# 下面的pandas.DataFrame的特性, df=False时将不可用
# 行的索引可以是整数, 也可以是日期的各种形式:
h['open']['2015-01-05']
h['open'][datetime.date(2015, 1, 5)]
h['open'][datetime.datetime(2015, 1, 5)]

# 按行取数据
h.iloc[-1] #昨天的开盘价和收盘价, 一个pd.Series对象, index是字符串:'open'/'close'
h.iloc[-1]['open'] #昨天的开盘价
h.loc['2015-01-05']['open']

# 高级运算
h = h[h['volume'] > 1000000] # 只保留交易量>1000000股的行
h['open'] = h['open']/h['factor'] #让open列都跟factor列相除, 把价格都转化成原始价格
h['close'] = h['close']/h['factor']
get_current_data ♠ - 获取当前时间数据
get_current_data()
回测环境/模拟专用API

获取当前单位时间（当天/当前分钟）的涨跌停价, 是否停牌，当天的开盘价等。

回测时, 通过 API 获取到的是前一个单位时间(天/分钟)的数据, 而有些数据, 我们在这个单位时间是知道的, 比如涨跌停价, 是否停牌, 当天的开盘价. 我们添加了这个API用来获取这些数据.

参数

现在不需要传入, 即使传入了, 返回的 dict 也是空的, dict 的 value 会按需获取.
返回值 一个dict, 其中 key 是股票代码, value 是拥有如下属性的对象

last_price : 最新价
high_limit: 涨停价
low_limit: 跌停价
paused: 是否停止或者暂停了交易, 当停牌、未上市或者退市后返回 True
is_st: 是否是 ST(包括ST, *ST)，是则返回 True，否则返回 False
day_open: 当天开盘价
name: 股票现在的名称, 可以用这个来判断股票当天是否是 ST, *ST, 是否快要退市
industry_code: 股票现在所属行业代码, 参见 行业概念数据
注意

为了加速, 返回的 dict 里面的数据是按需获取的, dict 初始是空的, 当你使用 current_data[security] 时(假设 current_data 是返回的 dict), 该 security 的数据才会被获取.
返回的结果只在当天有效, 请不要存起来到隔天再用.
该函数仅仅限在要获取数据的标的在交易时段时调用
示例

def handle_data(context, data):
    current_data = get_current_data()
    print current_data
    print current_data['000001.XSHE']
    print current_data['000001.XSHE'].paused
    print current_data['000001.XSHE'].day_open
get_bars - 获取历史数据
get_bars(security, count, unit='1d',
                 fields=['date', 'open','high','low','close'],
                 include_now=False, end_dt=None, fq_ref_date=None)
获取各种时间周期的 bar 数据， bar 的分割方式与主流股票软件相同， 而且支持返回当前时刻所在 bar 的数据。

参数

security: 股票代码
count: 大于0的整数，表示获取bar的个数。如果行情数据的bar不足count个，返回的长度则小于count个数。
unit: bar的时间单位, 支持如下周期：'1m', '5m', '15m', '30m', '60m', '120m', '1d', '1w', '1M'。'1w' 表示一周，‘1M' 表示一月。
fields: 获取数据的字段， 支持如下值：'date', 'open', 'close', 'high', 'low', 'volume', 'money'
include_now: 取值True 或者False。 表示是否包含当前bar, 比如策略时间是9:33，unit参数为5m， 如果 include_now=True,则返回9:30-9:33这个分钟 bar。
end_dt：查询的截止时间，支持的类型为datetime.datetime或None。为None在回测模拟环境下默认为context.current_dt，在研究环境下默认为datetime.now()，支持的格式为。
fq_ref_date：复权基准日期，为None时为不复权数据。注意在回测及模拟交易中，默认为None，即不复权数据；在研究环境中，默认复权基准日期为当天。
返回值

一个 numpy.ndarry 对象。可以通过 array['close'] 的方式直接访问列数据。

示例

array = get_bars('000001.XSHG', 5, unit='1d',fields=['open','close'],include_now=False)
array['close']
get_extras - 获取基金净值/期货结算价等
get_extras(info, security_list, start_date='2015-01-01', end_date='2015-12-31', df=True, count=None)
得到多只标的在一段时间的如下额外的数据:

is_st: 是否是ST，是则返回 True，否则返回 False
acc_net_value: 基金累计净值
unit_net_value: 基金单位净值
futures_sett_price: 期货结算价
futures_positions: 期货持仓量
adj_net_value: 场外基金的复权净值
参数

info: ['is_st', 'acc_net_value', 'unit_net_value', 'futures_sett_price', 'futures_positions'] 中的一个
security_list: 股票列表
start_date/end_date: 开始结束日期, 同 [get_price]
df: 返回[pandas.DataFrame]对象还是一个dict, 同 [history]
count: 数量, 与 start_date 二选一, 不可同时使用, 必须大于 0. 表示取 end_date 往前的 count 个交易日的数据
返回值

df=True: [pandas.DataFrame]对象, 列索引是股票代号, 行索引是[datetime.datetime], 比如get_extras('acc_net_value', ['510300.XSHG', '510050.XSHG'], start_date='2015-12-01', end_date='2015-12-03')返回:
---	510300.XSHG	510050.XSHG
2015-12-01 00:00:00	1.395	3.119
2015-12-02 00:00:00	1.4432	3.251
2015-12-03 00:00:00	1.4535	3.254
get_extras('is_st', ['000001.XSHE', '000018.XSHE'], start_date='2013-12-01', end_date='2013-12-03')返回:

---	000001.XSHE	000018.XSHE
2013-12-02 00:00:00	False	True
2013-12-03 00:00:00	False	True
df=False 一个dict, key是基金代号, value是[numpy.ndarray], 比如get_extras('acc_net_value', ['510300.XSHG', '510050.XSHG'], start_date='2015-12-01', end_date='2015-12-03', df=False) 返回:
{
    u'510050.XSHG': array([ 3.119,  3.251,  3.254]),
    u'510300.XSHG': array([ 1.395 ,  1.4432,  1.4535])
}
get_factor_values - 聚宽因子库
# 导入函数库
from jqfactor import get_factor_values
# 取值函数
get_factor_values(securities, factors, start_date, end_date, count)
获取质量因子、基础因子、情绪因子、成长因子、风险因子、每股因子等数百个因子数据，详细的因子列表请参考因子库

参数

securities:股票池，单只股票（字符串）或一个股票列表
factors: 因子名称，单个因子（字符串）或一个因子列表
start_date:开始日期，字符串或 datetime 对象，与 coun t参数二选一
end_date: 结束日期， 字符串或 datetime 对象，可以与 start_date 或 count 配合使用
count: 截止 end_date 之前交易日的数量（含 end_date 当日），与 start_date 参数二选一
返回

一个 dict： key 是因子名称， value 是 pandas.dataframe。
dataframe 的 index 是日期， column 是股票代码， value 是因子值
示例

# 导入函数库
from jqfactor import get_factor_values

# 获取因子Skewness60(个股收益的60日偏度)从 2017-01-01 至 2017-03-04 的因子值
factor_data = get_factor_values(securities=['000001.XSHE'], factors=['Skewness60'], start_date='2017-01-01', end_date='2017-03-04')
# 查看因子值
factor_data['Skewness60']
get_fundamentals - 查询财务数据
get_fundamentals(query_object, date=None, statDate=None)
查询财务数据，详细的数据字段描述请点击财务数据文档查看

date和statDate参数只能传入一个:

传入date时, 查询指定日期date收盘后所能看到的最近(对市值表来说, 最近一天, 对其他表来说, 最近一个季度)的数据, 我们会查找上市公司在这个日期之前(包括此日期)发布的数据, 不会有未来函数.
传入statDate时, 查询 statDate 指定的季度或者年份的财务数据. 注意:
由于公司发布财报不及时, 一般是看不到当季度或年份的财务报表的, 回测中使用这个数据可能会有未来函数, 请注意规避.
由于估值表每天更新, 当按季度或者年份查询时, 返回季度或者年份最后一天的数据
由于“资产负债数据”这个表是存量性质的， 查询年度数据是返回第四季度的数据。
银行业、券商、保险专项数据只有年报数据，需传入statDate参数，当传入 date 参数 或 statDate 传入季度时返回空，请自行避免未来函数。
当 date 和 statDate 都不传入时, 相当于使用 date 参数, date 的默认值下面会描述.

参数

query_object: 一个sqlalchemy.orm.query.Query对象, 可以通过全局的 query 函数获取 Query 对象
date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:
回测模块: 默认值会随着回测日期变化而变化, 等于 context.current_dt 的前一天(实际生活中我们只能看到前一天的财报和市值数据, 所以要用前一天)
研究模块: 使用平台财务数据的最新日期, 一般是昨天. 如果传入的 date 不是交易日, 则使用这个日期之前的最近的一个交易日
statDate: 财报统计的季度或者年份, 一个字符串, 有两种格式:
季度: 格式是: 年 + 'q' + 季度序号, 例如: '2015q1', '2013q4'.
年份: 格式就是年份的数字, 例如: '2015', '2016'.
返回 返回一个 [pandas.DataFrame], 每一行对应数据库返回的每一行(可能是几个表的联合查询结果的一行), 列索引是你查询的所有字段 注意：

为了防止返回数据量过大, 我们每次最多返回10000行
当相关股票上市前、退市后，财务数据返回各字段为空
示例

# 查询'000001.XSHE'的所有市值数据, 时间是2015-10-15
q = query(
    valuation
).filter(
    valuation.code == '000001.XSHE'
)
df = get_fundamentals(q, '2015-10-15')
# 打印出总市值
log.info(df['market_cap'][0])
# 获取多只股票在某一日期的市值, 利润
df = get_fundamentals(query(
        valuation, income
    ).filter(
        # 这里不能使用 in 操作, 要使用in_()函数
        valuation.code.in_(['000001.XSHE', '600000.XSHG'])
    ), date='2015-10-15')
# 选出所有的总市值大于1000亿元, 市盈率小于10, 营业总收入大于200亿元的股票
df = get_fundamentals(query(
        valuation.code, valuation.market_cap, valuation.pe_ratio, income.total_operating_revenue
    ).filter(
        valuation.market_cap > 1000,
        valuation.pe_ratio < 10,
        income.total_operating_revenue > 2e10
    ).order_by(
        # 按市值降序排列
        valuation.market_cap.desc()
    ).limit(
        # 最多返回100个
        100
    ), date='2015-10-15')
# 使用 or_ 函数: 查询总市值大于1000亿元 **或者** 市盈率小于10的股票
from sqlalchemy.sql.expression import or_
get_fundamentals(query(
        valuation.code
    ).filter(
        or_(
            valuation.market_cap > 1000,
            valuation.pe_ratio < 10
        )
    ))
# 查询平安银行2014年四个季度的季报, 放到数组中
q = query(
        income.statDate,
        income.code,
        income.basic_eps,
        balance.cash_equivalents,
        cash_flow.goods_sale_and_service_render_cash
    ).filter(
        income.code == '000001.XSHE',
    )

rets = [get_fundamentals(q, statDate='2014q'+str(i)) for i in range(1, 5)]
# 查询平安银行2014年的年报
q = query(
        income.statDate,
        income.code,
        income.basic_eps,
        cash_flow.goods_sale_and_service_render_cash
    ).filter(
        income.code == '000001.XSHE',
    )

ret = get_fundamentals(q, statDate='2014')
get_fundamentals_continuously - 查询多日的财务数据
get_fundamentals_continuously(query_object, end_date=None,count=None)
查询财务数据，详细的数据字段描述请点击财务数据文档查看

参数

query_object: 一个sqlalchemy.orm.query.Query对象, 可以通过全局的 query 函数获取 Query 对象
end_date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:
回测模块: 默认值会随着回测日期变化而变化, 等于 context.current_dt 的前一天(实际生活中我们只能看到前一天的财报和市值数据, 所以要用前一天)
研究模块: 使用平台财务数据的最新日期, 一般是昨天. 如果传入的 date 不是交易日, 则使用这个日期之前的最近的一个交易日
count: 获取 end_date 前 count 个日期的数据
返回 返回一个 [pandas.Panel]

出于性能方面考虑，我们做出了返回总条数不超过10000条的限制。 也就是说：查询的股票数量*count 要小于10000。 否则，返回的数据会不完整。

示例

>>> q = query(valuation.turnover_ratio,
              valuation.market_cap,
              indicator.eps
            ).filter(valuation.code.in_(['000001.XSHE', '600000.XSHG']))

>>> panel = get_fundamentals_continuously(q, end_date='2018-01-01', count=5)

>>> panel 

<class 'pandas.core.panel.Panel'>
Dimensions: 3 (items) x 5 (major_axis) x 2 (minor_axis)
Items axis: turnover_ratio to eps
Major_axis axis: 2017-12-25 to 2017-12-29
Minor_axis axis: 000001.XSHE to 600000.XSHG

>>> panel.minor_xs('600000.XSHG')

turnover_ratio  market_cap  eps
day         
2017-12-25  0.0687  3695.4270   0.48
2017-12-26  0.0542  3710.1030   0.48
2017-12-27  0.1165  3704.2324   0.48
2017-12-28  0.0849  3680.7510   0.48
2017-12-29  0.0582  3695.4270   0.48


>>> panel.major_xs('2017-12-25')

turnover_ratio  market_cap  eps
code            
000001.XSHE 0.9372  2275.0796   0.38
600000.XSHG 0.0687  3695.4270   0.48

>>> panel.xs('turnover_ratio',axis=0)
# axis=0 表示 items axis; axis=1 表示 major axis; axis=2 表示 minor axis

code    000001.XSHE 600000.XSHG
day     
2017-12-25  0.9372  0.0687
2017-12-26  0.6642  0.0542
2017-12-27  0.8078  0.1165
2017-12-28  0.9180  0.0849
2017-12-29  0.5810  0.0582
finance.run_query - 深沪港通股东信息等数据
数据调用方法

from jqdata import *
finance.run_query(query_object)
查询深沪港通、股东信息、公司概况等数据，详细的数据字段描述请点击股票数据查看

参数

query_object: 一个sqlalchemy.orm.query.Query对象, 可以通过全局的query函数获取Query对象。
返回 返回一个 dataframe， 每一行对应数据库返回的每一行， 列索引是你所查询的字段

注意

为了防止返回数据量过大, 我们每次最多返回3000行
不能进行连表查询，即同时查询多张表内数据
示例

# 查询万科 AH 股价格的前10条数据
q=query(finance.STK_AH_PRICE_COMP
  ).filter(
        finance.STK_AH_PRICE_COMP.a_code=='000002.XSHE'
  ).order_by(
        finance.STK_AH_PRICE_COMP.day
  ).limit(10)
df=finance.run_query(q)
# 指定查询对象为恒瑞医药（600276.XSHG)的十大股东情况，限定返回条数为10条
q=query(finance.STK_SHAREHOLDER_TOP10
  ).filter(
        finance.STK_SHAREHOLDER_TOP10.code=='600276.XSHG',
        finance.STK_SHAREHOLDER_TOP10.pub_date>'2015-01-01'
  ).limit(10)
df=finance.run_query(q)
jy.run_query - 更多财务及宏观数据
from jqdata import jy
jy.run_query(query_object)
查询聚源数据，详细的数据字段描述请点击聚源数据查看

参数

query_object: 一个sqlalchemy.orm.query.Query对象, 可以通过全局的query函数获取Query对象
返回

返回一个pandas.DataFrame, 每一行对应数据库返回的每一行, 列索引是你查询的所有字段
注意

为了防止返回数据量过大, 我们每次最多返回3000行
不能进行连表查询，即同时查询多张表内数据
示例

# 查询'股票基本信息表 - STK_STOCKINFO'的数据, 并返回前10条数据
from jqdata import jy
df = jy.run_query(query(jy.LC_StockArchives).limit(10))

# 打印出公司名称
log.info(df['ChiName'])
macro.run_query - 获取聚宽宏观经济数据
get_index_stocks - 获取指数成份股
get_index_stocks(index_symbol, date=None)
获取一个指数给定日期在平台可交易的成分股列表，请点击指数列表查看指数信息

参数

index_symbol: 指数代码
date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:
回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt
研究模块: 默认是今天
返回 返回股票代码的list

示例

# 获取所有沪深300的股票
stocks = get_index_stocks('000300.XSHG')
log.info(stocks)
get_index_weights - 获取指数成分股权重
get_index_weights(index_id, date=None)
参数

index_id: 必选参数，代表指数的标准形式代码， 形式：指数代码.交易所代码，例如"000001.XSHG"。若代码格式错误或传入无效的指数代码，报错。
date: 可选参数， 查询权重信息的日期，形式："%Y-%m-%d"，例如"2018-05-03"，除此之外其他日期格式报错。当date为None，在回测、模拟环境中，默认为context.current_dt.date()；在研究环境中，默认为datetime.now().date()。
返回

查询到对应日期，且有权重数据，返回 pandas.DataFrame， index 是股票代码，columns 为 display_name(股票名称), date(日期), weight(权重)；
查询到对应日期，且无权重数据， 返回距离查询日期最近日期的权重信息；
找不到对应日期的权重信息， 返回距离查询日期最近日期的权重信息；
示例

>>> get_index_weights(index_id="000001.XSHG", date="2018-05-09")


=========== ============ =========== ======
    code    display_name     date    weight
=========== ============ =========== ======
000002.XSHG 万科A         2018-05-09  1.43
000001.XSHG 平安银行      2018-05-09  0.93
000009.XSHG 中国宝安      2018-05-09  0.27
=========== ============ =========== ======
get_industry_stocks - 获取行业成份股
get_industry_stocks(industry_code, date=None)
获取在给定日期一个行业的所有股票，行业分类列表见数据页面-行业概念数据。

参数

industry_code: 行业编码
date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:
回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt
研究模块: 默认是今天
返回 返回股票代码的list

示例

# 获取计算机/互联网行业的成分股
stocks = get_industry_stocks('I64')
get_concept_stocks - 获取概念成份股
get_concept_stocks(concept_code, date=None)
获取在给定日期一个概念板块的所有股票，概念板块分类列表见数据页面-行业概念数据。

参数

concept_code: 概念板块编码
date: 查询日期, 一个字符串(格式类似'2015-10-15')或者[datetime.date]/[datetime.datetime]对象, 可以是None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别:
回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt
研究模块: 默认是今天
返回 返回股票代码的list

示例

# 获取风力发电概念板块的成分股
stocks = get_concept_stocks('GN036')
get_industries - 获取行业列表
from jqdata import *
get_industries(name='zjw')
按照行业分类获取行业列表。

参数

name: 行业代码， 取值如下：

"sw_l1": 申万一级行业
"sw_l2": 申万二级行业
"sw_l3": 申万三级行业
"jq_l1": 聚宽一级行业
"jq_l2": 聚宽二级行业
"zjw": 证监会行业
返回值

pandas.DataFrame， 各 column 的含义如下:

index: 行业代码
name: 行业名称
start_date: 开始日期
get_concepts - 获取概念列表
from jqdata import *
get_concepts()
获取概念板块列表

返回值

pandas.DataFrame， 各 column 的含义如下:

index: 概念代码
name: 概念名称
start_date: 开始日期
get_all_securities - 获取所有标的信息
get_all_securities(types=[], date=None)
获取平台支持的所有股票、基金、指数、期货信息

参数

types: list: 用来过滤securities的类型, list元素可选: 'stock', 'fund', 'index', 'futures', 'etf', 'lof', 'fja', 'fjb', 'open_fund', 'bond_fund', 'stock_fund', 'QDII_fund', 'money_market_fund', 'mixture_fund'。 types为空时返回所有股票, 不包括基金,指数和期货
date: 日期, 一个字符串或者 [datetime.datetime]/[datetime.date] 对象, 用于获取某日期还在上市的股票信息. 默认值为 None, 表示获取所有日期的股票信息
返回 [pandas.DataFrame], 比如:get_all_securities()[:2]返回:

---	display_name	name	start_date	end_date	type
000001.XSHE	平安银行	PAYH	1991-04-03	9999-01-01	stock
000002.XSHE	万 科Ａ	WKA	1991-01-29	9999-01-01	stock
display_name: 中文名称
name: 缩写简称
start_date: 上市日期
end_date: 退市日期，如果没有退市则为2200-01-01
type: 类型，stock(股票)，index(指数)，etf(ETF基金)，fja（分级A），fjb（分级B），fjm（分级母基金），mmf（场内交易的货币基金）open_fund（开放式基金）, bond_fund（债券基金）, stock_fund（股票型基金）, QDII_fund（QDII 基金）, money_market_fund（场外交易的货币基金）, mixture_fund（混合型基金）
示例

def initialize(context):
    #获得所有股票列表
    log.info(get_all_securities())
    log.info(get_all_securities(['stock']))

    #将所有股票列表转换成数组
    stocks = list(get_all_securities(['stock']).index)

    #获得所有指数列表
    get_all_securities(['index'])

    #获得所有基金列表
    df = get_all_securities(['fund'])

    #获取所有期货列表
    get_all_securities(['futures'])

    #获得etf基金列表
    df = get_all_securities(['etf'])
    #获得lof基金列表
    df = get_all_securities(['lof'])
    #获得分级A基金列表
    df = get_all_securities(['fja'])
    #获得分级B基金列表
    df = get_all_securities(['fjb'])

    #获得2015年10月10日还在上市的所有股票列表
    get_all_securities(date='2015-10-10')
    #获得2015年10月10日还在上市的 etf 和 lof 基金列表
    get_all_securities(['etf', 'lof'], '2015-10-10')
get_security_info - 获取单个标的信息
get_security_info(code)
获取股票/基金/指数的信息.

参数

code: 证券代码
返回值

一个对象, 有如下属性:

display_name: 中文名称
name: 缩写简称
start_date: 上市日期, [datetime.date] 类型
end_date: 退市日期， [datetime.date] 类型, 如果没有退市则为2200-01-01
type: 股票、基金、金融期货、期货、债券基金、股票基金、QDII 基金、货币基金、混合基金、场外基金，'stock'/ 'fund' / 'index_futures' / 'futures' / 'etf'/'bond_fund' / 'stock_fund' / 'QDII_fund' / 'money_market_fund' / ‘mixture_fund' / 'open_fund'
parent: 分级基金的母基金代码
示例

# 获取基金的母基金, 下面的判断为真.
assert get_security_info('502050.XSHG').parent == '502048.XSHG'
get_industry - 查询股票所属行业
get_industry(security, date=None)
参数

security：标的代码。类型为字符串，形式如"000001.XSHE"；或为包含标的代码字符串的列表，形如["000001.XSHE", "000002.XSHE"]
date：查询的日期。类型为字符串，形如"2018-06-01"或"2018-06-01 09:00:00"；或为datetime.datetime对象和datetime.date。注意传入对象的时分秒将被忽略。
返回结果

一个dict， key是标的代码。

示例

>>> get_industry(security=['000001.XSHE','000002.XSHE'], date="2018-06-01")


{'000001.XSHE': {'jq_l1': {'industry_code': 'HY007', 'industry_name': '金融指数'},
                 'jq_l2': {'industry_code': 'HY493', 'industry_name': '多元化银行指数'},
                 'sw_l1': {'industry_code': '801780', 'industry_name': '银行I'},
                 'sw_l2': {'industry_code': '801192', 'industry_name': '银行II'},
                 'sw_l3': {'industry_code': '851911', 'industry_name': '银行III'},
                 'zjw': {'industry_code': 'J66', 'industry_name': '货币金融服务'}
                },
 '000002.XSHE': {'jq_l1': {'industry_code': 'HY011', 'industry_name': '房地产指数'},
                 'jq_l2': {'industry_code': 'HY509', 'industry_name': '房地产开发指数'},
                 'sw_l1': {'industry_code': '801180', 'industry_name': '房地产I'},
                 'sw_l2': {'industry_code': '801181', 'industry_name': '房地产开发II'},
                 'sw_l3': {'industry_code': '851811', 'industry_name': '房地产开发III'},
                 'zjw': {'industry_code': 'K70', 'industry_name': '房地产业'}
                }
}
get_billboard_list - 获取龙虎榜数据
get_billboard_list(stock_list, start_date, end_date, count)
获取指定日期区间内的龙虎榜数据

参数

stock_list: 一个股票代码的 list。 当值为 None 时， 返回指定日期的所有股票。
start_date:开始日期
end_date: 结束日期
count: 交易日数量， 可以与 end_date 同时使用， 表示获取 end_date 前 count 个交易日的数据(含 end_date 当日)
返回值

pandas.DataFrame， 各 column 的含义如下:

code: 股票代码
day: 日期
direction: ALL 表示『汇总』，SELL 表示『卖』，BUY 表示『买』
abnormal_code: 异常波动类型
abnormal_name: 异常波动名称
sales_depart_name: 营业部名称
rank: 0 表示汇总， 1~5 表示买一到买5， 6~10 表示卖一到卖五
buy_value:买入金额
buy_rate:买入金额占比(买入金额/市场总成交额)
sell_value:卖出金额
sell_rate:卖出金额占比(卖出金额/市场总成交额)
net_value:净额(买入金额 - 卖出金额)
amount:市场总成交额
示例

# 在策略中获取前一日的龙虎榜数据
get_billboard_list(stock_list=None, end_date = context.previous_date, count =1)
get_locked_shares - 获取限售解禁数据
get_locked_shares(stock_list, start_date, end_date, forward_count)
获取指定日期区间内的限售解禁数据

参数

stock_list: 一个股票代码的 list
start_date: 开始日期
end_date: 结束日期
forward_count: 交易日数量， 可以与 start_date 同时使用， 表示获取 start_date 到 forward_count 个交易日区间的数据
返回值

pandas.DataFrame， 各 column 的含义如下:

day: 解禁日期
code: 股票代码
num: 解禁股数
rate1: 解禁股数/总股本
rate2: 解禁股数/总流通股本
示例

# 在策略中获取个股未来500天的解禁情况
get_locked_shares(stock_list=['000001.XSHE', '000002.XSHE'], start_date=context.current_dt, forward_count=500)
get_all_trade_days - 获取所有交易日
from jqdata import *
get_all_trade_days()
获取所有交易日, 不需要传入参数, 返回一个包含所有交易日的 [numpy.ndarray], 每个元素为一个 [datetime.date] 类型.

注： 需导入 jqdata 模块，即在策略或研究起始位置加入import jqdata

get_trade_days - 获取指定范围交易日
from jqdata import *
get_trade_days(start_date=None, end_date=None, count=None)
获取指定日期范围内的所有交易日, 返回一个包含datetime.date object的列表, 包含指定的 start_date 和 end_date, 默认返回至 datatime.date.today() 的所有交易日

注： 需导入 jqdata 模块，即在策略或研究起始位置加入import jqdata

参数

start_date: 开始日期, 与 count 二选一, 不可同时使用. str/[datetime.date]/[datetime.datetime] 对象
end_date: 结束日期, str/[datetime.date]/[datetime.datetime] 对象, 默认为 datetime.date.today()
count: 数量, 与 start_date 二选一, 不可同时使用, 必须大于 0. 表示取 end_date 往前的 count 个交易日，包含 end_date 当天。
get_money_flow - 获取资金流信息
from jqdata import *
get_money_flow(security_list, start_date=None, end_date=None, fields=None, count=None)
获取一只或者多只股票在一个时间段内的资金流向数据，仅包含股票数据，不可用于获取期货数据。

注： 需导入 jqdata 模块，即在策略或研究起始位置加入import jqdata

参数

security_list: 一只股票代码或者一个股票代码的 list
start_date: 开始日期, 与 count 二选一, 不可同时使用, 一个字符串或者 [datetime.datetime]/[datetime.date] 对象, 默认为平台提供的数据的最早日期
end_date: 结束日期, 一个字符串或者 [datetime.date]/[datetime.datetime] 对象, 默认为 datetime.date.today()
count: 数量, 与 start_date 二选一，不可同时使用, 必须大于 0. 表示返回 end_date 之前 count 个交易日的数据, 包含 end_date
fields: 字段名或者 list, 可选. 默认为 None, 表示取全部字段, 各字段含义如下：
字段名	含义	备注
date	日期	---
sec_code	股票代码	---
change_pct	涨跌幅(%)	---
net_amount_main	主力净额(万)	主力净额 = 超大单净额 + 大单净额
net_pct_main	主力净占比(%)	主力净占比 = 主力净额 / 成交额
net_amount_xl	超大单净额(万)	超大单：大于等于50万股或者100万元的成交单
net_pct_xl	超大单净占比(%)	超大单净占比 = 超大单净额 / 成交额
net_amount_l	大单净额(万)	大单：大于等于10万股或者20万元且小于50万股或者100万元的成交单
net_pct_l	大单净占比(%)	大单净占比 = 大单净额 / 成交额
net_amount_m	中单净额(万)	中单：大于等于2万股或者4万元且小于10万股或者20万元的成交单
net_pct_m	中单净占比(%)	中单净占比 = 中单净额 / 成交额
net_amount_s	小单净额(万)	小单：小于2万股或者4万元的成交单
net_pct_s	小单净占比(%)	小单净占比 = 小单净额 / 成交额
返回

返回一个 [pandas.DataFrame] 对象，默认的列索引为取得的全部字段. 如果给定了 fields 参数, 则列索引与给定的 fields 对应.

示例

# 获取一只股票在一个时间段内的资金流量数据
jqdata.get_money_flow('000001.XSHE', '2016-02-01', '2016-02-04')
jqdata.get_money_flow('000001.XSHE', '2015-10-01', '2015-12-30', fields="change_pct")
jqdata.get_money_flow(['000001.XSHE'], '2010-01-01', '2010-01-30', ["date", "sec_code", "change_pct", "net_amount_main", "net_pct_l", "net_amount_m"])

— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —

# 获取多只股票在一个时间段内的资金流向数据
jqdata.get_money_flow(['000001.XSHE', '000040.XSHE', '000099.XSHE'], '2010-01-01', '2010-01-30')
# 获取多只股票在某一天的资金流向数据
jqdata.get_money_flow(['000001.XSHE', '000040.XSHE', '000099.XSHE'], '2016-04-01', '2016-04-01')

— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —

# 获取股票 000001.XSHE 在日期 2016-06-30 往前 20 个交易日的资金流量数据
jqdata.get_money_flow('000001.XSHE', end_date="2016-06-30", count=20)
# 获取股票 000001.XSHE 往前 20 个交易日的资金流量数据
jqdata.get_money_flow('000001.XSHE', count=20)
数据处理函数
neutralize - 中性化
neutralize(series, how=None, date=None, axis=1)
参数

data: pd.Series/pd.DataFrame , 待中性化的序列，序列的 index 为股票的 code
how: str list 。 中性化使用的因子名称列表。默认为 ['jq_l1', 'market_cap'] 支持的内容包括：
'jq_l1'： 聚宽一级行业
'jq_l2'： 聚宽二级行业
'sw_l1'： 申万一级行业
'sw_l2'： 申万二级行业
'sw_l3'： 申万三级行业
barra 的风险因子：可以使用的风险因子包括： ['size', 'beta', 'momentum', 'residual_volatility', 'non_linear_size', 'book_to_price_ratio', 'liquidity', 'earnings_yield', 'growth', 'leverage']
date: 日期格式 str 将用 date 这天的相关变量数据对 series 进行中性化
axis: 默认为 1。仅在 data 为 pd.DataFrame 时生效。 表示沿哪个方向做标准化，0 为对每列做中性化，1 为对每行做中性化
返回

中性化后的因子数据

示例

# 导入需要的函数库
import pandas as pd
import numpy as np
from jqfactor import neutralize
# 生成数据
data = pd.DataFrame(np.random.rand(3,300), columns=get_index_stocks('000300.XSHG', date='2018-05-02'),index=['a', 'b', 'c'])
# 数据中性化
neutralize(data, how=['jq_l1', 'market_cap'], date='2018-05-02', axis=1)
winsorize - 去极值
winsorize(series, scale=None, range=None, qrange=None, inclusive=True, inf2nan=True, axis=1)
参数

data: pd.Series/pd.DataFrame/np.array, 待缩尾的序列
scale: 标准差倍数，与 range，qrange 三选一，不可同时使用。会将位于 [mu - scale * sigma, mu + scale * sigma] 边界之外的值替换为边界值
range: 列表， 缩尾的上下边界。与 scale，qrange 三选一，不可同时使用。
qrange: 列表，缩尾的上下分位数边界，值应在 0 到 1 之间，如 [0.05, 0.95]。与 scale，range 三选一，不可同时使用。
inclusive: 是否将位于边界之外的值替换为边界值，默认为 True。如果为 True，则将边界之外的值替换为边界值，否则则替换为 np.nan
inf2nan: 是否将 np.inf 和 -np.inf 替换成 np.nan，默认为 True如果为 True，在缩尾之前会先将 np.inf 和 -np.inf 替换成 np.nan，缩尾的时候不会考虑 np.nan，否则 inf 被认为是在上界之上，-inf 被认为在下界之下
axis: 在 data 为 pd.DataFrame 时使用，沿哪个方向做标准化，默认为 1。 0 为对每列做缩尾，1 为对每行做缩尾。
返回

去极值处理之后的因子数据

示例

# 导入需要的函数库
import pandas as pd
import numpy as np
from jqfactor import winsorize
# 生成数据
data = pd.DataFrame(np.random.rand(3,300), columns=get_index_stocks('000300.XSHG', date='2018-05-02'),index=['a', 'b', 'c'])
# 数据去极值
winsorize(data, qrange=[0.05,0.93], inclusive=True, inf2nan=True, axis=1)
winsorize_med - 中位数去极值
winsorize_med(series, scale=1, inclusive=True, inf2nan=True, axis=1)
参数

data: pd.Series/pd.DataFrame/np.array, 待缩尾的序列
scale: 倍数，默认为 1.0。会将位于 [med - scale * distance, med + scale * distance] 边界之外的值替换为边界值/np.nan
inclusive bool 是否将位于边界之外的值替换为边界值，默认为 True。 如果为 True，则将边界之外的值替换为边界值，否则则替换为 np.nan
inf2nan: 是否将 np.inf 和 -np.inf 替换成 np.nan，默认为 True。如果为 True，在缩尾之前会先将 np.inf 和 -np.inf 替换成 np.nan，缩尾的时候不会考虑 np.nan，否则 inf 被认为是在上界之上，-inf 被认为在下界之下
axis: 在 data 为 pd.DataFrame 时使用，沿哪个方向做标准化，默认为 1。0 为对每列做缩尾，1 为对每行做缩尾
返回

中位数去极值之后的因子数据

示例

# 导入需要的函数库
import pandas as pd
import numpy as np
from jqfactor import winsorize_med
# 生成数据
data = pd.DataFrame(np.random.rand(3,300), columns=get_index_stocks('000300.XSHG', date='2018-05-02'),index=['a', 'b', 'c'])
# 数据中位数去极值
winsorize_med(data, scale=1, inclusive=True, inf2nan=True, axis=0)
standardlize - 标准化
standardlize(series, inf2nan=True, axis=1)
参数

data: pd.Series/pd.DataFrame/np.array, 待标准化的序列
inf2nan: 是否将 np.inf 和 -np.inf 替换成 np.nan。默认为 True
axis=1: 在 data 为 pd.DataFrame 时使用，如果 series 为 pd.DataFrame，沿哪个方向做标准化。0 为对每列做标准化，1 为对每行做标准化
返回

标准化后的因子数据

示例

# 导入需要的函数库
import pandas as pd
import numpy as np
from jqfactor import standardlize
# 生成数据
data = pd.DataFrame(np.random.rand(3,300), columns=get_index_stocks('000300.XSHG', date='2018-05-02'),index=['a', 'b', 'c'])
# 数据标准化
standardlize(data, inf2nan=True, axis=0)
组合优化函数
portfolio_optimizer - 投资组合优化
portfolio_optimizer(date, securities, target, constraints, bounds=[Bound(0.0, 1.0)], default_port_weight_range=[0.0, 1.0], ftol=1e-9, return_none_if_fail=True)
优化函数, 用于计算在某些约束条件下的最优组合权重

参数
date: 优化发生的日期，请注意未来函数
securities: 股票代码列表
target: 优化目标函数，只能选择一个，目标函数详见下方
constraints: 限制函数，用以对组合总权重进行限制，可设置一个或多个相同/不同类别的函数，限制函数详见下方
bounds: 边界函数，用以对组合中单标的权重进行限制，可设置一个或多个相同/不同类别的函数，边界函数详见下方。如果不填，默认为 Bound(0., 1.)；如果有多个 bound，则一只股票的权重下限取所有 Bound 的最大值，上限取所有 Bound 的最小值
default_port_weight_range: 长度为2的列表，默认的组合权重之和的范围，默认值为 [0.0, 1.0]。如果限制函数(constraints) 中没有 WeightConstraint 或 WeightEqualConstraint 限制，则会添加 WeightConstraint(low=default_port_weight_range[0], high=default_port_weight_range[1]) 到 constraints列表中。
ftol: 默认为 1e-9，优化函数触发结束的函数值。当求解结果精度不够时可以适当降低 ftol 的值，当求解时间过长时可以适当提高 ftol 值
return_none_if_fail: 默认为 True，如果优化失败，当 return_none_if_fail 为 True 时返回 None，为 False 时返回全为 0 的组合权重
目标函数(target)

MiniVariance(count=250) - 组合风险最小化（最小化组合方差）

​ 最小化组合方差

参数：

count: 默认为 250，向前取 returns 的天数

示例：

target = MiniVariance(count=250)

MaxProfit(count=250) - 组合收益最大化

参数：

count: 默认为 250，向前取 returns 的天数

示例：

target = MaxProfit(count=250)

MaxSharpeRatio(rf=0.0, weight_sum_equal=1.0, count=250) - 组合夏普比率最大化

参数：

rf: 年化无风险利率，默认为 0

weight_sum_equal：组合总权重的值（默认值为1.0），在该权重下进行优化，使得组合的夏普比率最大化

count: 默认为 250，向前取 returns 的天数

示例：

target = MaxSharpeRatio(count=250)

MinTrackingError(benchmark, count=250) - 追踪误差最小化

参数：

benchmark: 基准的 ticker，例如 '000300.XSHG'

count: 默认为 250，向前取 returns 的天数

示例：

target = MinTrackingError(benchmark='000300.XSHG', count=250)

RiskParity(count=250, risk_budget=None) - 风险平价

风险平价（Risk Parity）是对投资组合中不同资产分配相同的风险权重的一种资产配置理念，资产配置的风险平价方法允许投资者针对具体的风险水平，并在整个投资组合中平均分配风险，以实现每个投资者的最佳投资组合多元化。

参数：

count: 默认为 250，向前取 returns 的天数

risk_budget: pandas.Series，风险预算，股票的每只对组合风险的贡献，risk_budget 为 None默认为每只股票贡献相等

示例：

target = RiskParity(count=250, risk_budget=pd.Series([0.3, 0.3, 0.4], index=['000001.XSHE', '000002.XSHE', '000005.XSHE']))

MaxScore(scores) - 打分最大化

在满足约束条件的情况下，给予打分高的标的更高权重（前提假设：用户已知晓打分大的标的表现更好）。

如有经过因子分析检验，打分越高越有正向效果的[A,B,C] 三只标的，打分分别为 [3,2,1] , 约束条件为年化波动率小于15%。 如果组合全部配置A可获得最高的收益，但波动率大于15%，不满足约束条件；通过优化器优化，则会配置一定比例的B与C，在满足波动率小于15%的条件下，获得最高收益。

参数：

scores: pandas.Series，每只股票的打分

示例：

target = MaxScore(scores=pd.Series([0.1, 0.2, 0.3], index=['000001.XSHE', '000002.XSHE', '000005.XSHE']))

MinScore(scores) - 打分最小化

在满足约束条件的情况下，给予打分低的标的更高权重（前提假设：用户已知晓打分小的标的表现更好）。可参考 [打分最大化] 的示例说明。

参数：

scores: pandas.Series，每只股票的打分

示例：

target = MinScore(scores=pd.Series([0.1, 0.2, 0.3], index=['000001.XSHE', '000002.XSHE', '000005.XSHE']))

MaxFactorValue(factor, count=1) - 因子值最大化

在满足约束条件的情况下，给予因子值大的标的更高权重（前提假设：用户已知晓因子值大的标的表现更好）。可参考 [打分最大化] 的示例说明。

参数：

factor: Factor 的子类

count: 默认为 1，用过去几天的因子取平均

示例：

from jqfactor import Factor
# 定义因子：人气指标5日均值
class AR(Factor):
  name = 'AR_M5'
  # 每天获取过去五日的数据
  max_window = 5
  # 获取的数据是人气指标
  dependencies = ['AR']
  def calc(self, data):
      return data['AR'].mean()

target = MaxFactorValue(factor=AR, count=1)
MinFactorValue(factor, count=1) - 因子值最小化

在满足约束条件的情况下，给予因子值小的标的更高权重（前提假设：用户已知晓因子值小的标的表现更好）。可参考 [打分最大化] 的示例说明。

参数：

factor: Factor 的子类

count: 默认为 1，用过去几天的因子取平均

示例：

参考 [因子值最大化] 的示例

限制函数(constraints)

WeightConstraint(low=0.0, high=1.0) - 组合总权重限制

设定组合优化结果总权重的上下限，即优化结果的总权重在此范围间。

参数：

low: 默认为 0.0，权重下限

high: 默认为 1.0，权重上限

示例：

constraint = WeightConstraint(low=0.5, high=0.9)

WeightEqualConstraint(limit=1.0) - 组合总权重和限制

设定组合优化结果总权重的和，即优化结果的总权重等于该值。

参数：

limit: 默认为 1.0，组合权重等式约束

示例：

constraint = WeightEqualConstraint(limit=0.5)

AnnualStdConstraint(limit, count=250) - 组合年化收益率标准差限制

参数：

limit: 标准差上限

count: 默认为 250，向前取 returns 的天数

示例：

constraint = AnnualStdConstraint(limit=0.15, count=250)

AnnualProfitConstraint(limit, count=250) - 组合年化收益率预期限制

参数：

limit: 收益率预期下限

count: 默认为 250，向前取 returns 的天数

示例：

constraint = AnnualProfitConstraint(limit=0.1, count=250)

IndustryConstraint(industry_code, low=0.0, high=1.0) - 组合行业权重限制

参数：

industry_code: 单一或多个行业代码，如 'HY001'。如果为多个行业代码的列表，则表示所有属于列表中行业的股票的权重之和满足限制条件

low: 默认为 0.0，行业权重下限

high: 默认为 1.0，行业权重上限

示例：

constraint = IndustryConstraint(['HY007'], low=0.0, high=0.2)

IndustriesConstraint(industry_code, low=0.0, high=1.0)- 组合行业分类权重限制

参数：

industry_code: 行业分类代码，如 'jq_l1'。表示这个行业分类下的所有行业都需满足权重限制

low: 默认为 0.0，行业权重下限

high: 默认为 1.0，行业权重上限

示例：

constraint = IndustriesConstraint('jq_l1', low=0.0, high=0.2)

MarketConstraint(market_type, low=0.0, high=1.0) - 组合市场权重限制

参数：

market_type: ('stock', 'index', 'fund', 'futures', 'etf', 'lof', 'fja', 'fjb', 'open_fund', 'bond_fund', 'stock_fund', 'QDII_fund', 'money_market_fund', 'mixture_fund') 中的一种

low: 默认为 0.0，市场权重下限

high: 默认为 1.0，市场权重上限

示例：

constraint = MarketConstraint('stock', low=0.0, high=0.2)

ExposureConstraint(factor, low=0.0, high=1.0, count=1) - 因子暴露限制

参数：

factor: Factor 的子类

low: 默认为 0.0，因子暴露度下限

high: 默认为 1.0，因子暴露度上限

count: 默认为 1，用过去几天的因子取平均

示例：

from jqfactor import Factor
# 定义因子：人气指标5日均值
class AR(Factor):
  name = 'AR_M5'
  # 每天获取过去五日的数据
  max_window = 5
  # 获取的数据是人气指标
  dependencies = ['AR']
  def calc(self, data):
      return data['AR'].mean()

constraint = ExposureConstraint(AR, low=0.0, high=10.0, count=1)
边界函数(bounds)

Bound(low=0.0, high=1.0) - 每只标的的权重限制

参数：

low: 默认为 0.0，每只标的的权重下限

high: 默认为 1.0，每只标的的权重上限

示例：

bound = Bound(low=0.0, high=0.1)

IndustryBound(industry_code, low=0.0, high=1.0) - 属于某一行业的每只股票的权重限制

参数：

industry_code: 单一行业代码或者行业代码的列表。

low: 默认为 0.0，如果一只股票属于所选行业，则股票权重的下限为 low，否则下限为 0

high: 默认为 1.0，如果一只股票属于所选行业，则股票权重的上限为 high，否则上限为 1

示例：

bound = IndustryBound(['HY001', 'HY007'], low=0.0, high=0.05)

示例代码

# 导入函数库
import pandas as pd
from jqdata import *
from jqfactor import Factor
from jqlib.optimizer import *

# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)

    # 过滤掉order系列API产生的比error级别低的log
    log.set_level('order', 'error')

    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003,
                            min_commission=5), type='stock')

    # 优化器设置
    g.optimizer = 2 #设定使用的优化模型
    optimize_model = {
                        1:"模型1：等权重配置",
                        2:"模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%",
                        3:"模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%",
                        4:"模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%",
                        5:"模型5：组合夏普比率最大化；每只标的权重不超过10%"
                      }
    print("优化%s"%(optimize_model[g.optimizer]))

    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_monthly(before_market_open, monthday=1, time='before_open', reference_security='000300.XSHG')
      # 开盘运行
    run_monthly(market_open, monthday=1, time='open', reference_security='000300.XSHG')

## 开盘前运行函数
def before_market_open(context):
    print('调仓日期：%s'%context.current_dt.date())

    # 选出上证50成分股的一部分与选定的ETF基金进行组合,构成股票池。
    etf = [
        '159902.XSHE',
        '159903.XSHE',
        '510050.XSHG',
        '510880.XSHG',
        '510440.XSHG',
        ]
    g.buy_list = list(get_index_stocks('000016.XSHG')[-15:]) + etf

## 开盘时运行函数
def market_open(context):
    # 讲不在股票池中的股票卖出
    sell_list = set(context.portfolio.positions.keys()) - set(g.buy_list)
    for stock in sell_list:
        order_target_value(stock, 0)

    # 组合优化模型
    if g.optimizer == 1:
        # 模型1：等权重配置
        optimized_weight = pd.Series(data=[1.0/len(g.buy_list)]*len(g.buy_list),
                                    index=g.buy_list)
    elif g.optimizer == 2:
        # 模型2：组合风险平价；股票的总权重限制为0到90%，ETF的总权重限制为0到10%；每只标的权重不超过10%
        optimized_weight = portfolio_optimizer(date=context.previous_date,
                                    securities = g.buy_list,
                                    target = RiskParity(count=250, risk_budget=None),# risk_budget 为 None默认为每只股票贡献相等
                                    constraints = [MarketConstraint('stock', low=0.0, high=0.9),
                                                  MarketConstraint('etf', low=0.0, high=0.1)],
                                    bounds=[Bound(0, 0.1)],
                                    default_port_weight_range=[0., 1.0],
                                    ftol=1e-09,
                                    return_none_if_fail=True)
    elif g.optimizer == 3:
        # 模型3：组合风险最小化（最小化组合方差）；组合总权重限制为90%到100%；组合年化收益率目标下限为10%
        optimized_weight = portfolio_optimizer(date=context.previous_date,
                                    securities = g.buy_list,
                                    target = MinVariance(count=250),
                                    constraints = [WeightConstraint(low=0.9, high=1.0),
                                                   AnnualProfitConstraint(limit=0.1, count=250)],
                                    bounds=[],
                                    default_port_weight_range=[0., 1.0],
                                    ftol=1e-09,
                                    return_none_if_fail=True)
    elif g.optimizer == 4:
        # 模型4：组合标的因子值最大化

        # 定义因子：人气指标5日均值
        class AR(Factor):
            name = 'ar'
            # 每天获取过去五日的数据
            max_window = 5
            # 获取的数据是人气指标
            dependencies = ['AR']
            def calc(self, data):
                return data['AR'].mean()
        # 模型4：'人气指标5日均值'最大化；组合年化收益率目标下限为10%；每只标的权重不超过20%
        optimized_weight = portfolio_optimizer(date=context.previous_date,
                                    securities = g.buy_list,
                                    target = MaxFactorValue(factor=AR, count=1),
                                    constraints = [AnnualProfitConstraint(limit=0.2, count=250)],
                                    bounds=[Bound(0, 0.2)],
                                    default_port_weight_range=[0., 1.0],
                                    ftol=1e-09,
                                    return_none_if_fail=True)
    elif g.optimizer == 5:
        # 模型5：组合夏普比率最大化；每只标的权重不超过10%
        optimized_weight = portfolio_optimizer(date=context.previous_date,
                                    securities = g.buy_list,
                                    target = MaxSharpeRatio(rf=0.0,weight_sum_equal=0.5, count=250),#无风险利率为0，最大化夏普比率需要约束组合权重的和为0.5
                                    constraints = [],
                                    bounds=[Bound(0, 0.1)],
                                    default_port_weight_range=[0., 1.0],
                                    ftol=1e-09,
                                    return_none_if_fail=True)

    # 查看优化结果
    print(optimized_weight)

    # 优化失败，给予警告
    if type(optimized_weight) == type(None):
        print('警告：组合优化失败')
    # 按优化结果，执行调仓操作
    else:
        total_value = context.portfolio.total_value # 获取总资产
        for stock in optimized_weight.keys():
            value = total_value * optimized_weight[stock] # 确定每个标的的权重
            order_target_value(stock, value) # 调整标的至目标权重
jqlib
Alpha 101 因子
因子来源

根据 WorldQuant LLC 发表的论文 101 Formulaic Alphas 中给出的 101 个 Alphas 因子公式，我们将公式编写成了函数，方便大家使用。

详细介绍

函数计算公式、API 调用方法，输入输出值详情请见:数据 - Alpha 101.

使用方法

# 导入 Alpha101 库
>>> from jqlib.alpha101 import *

# 获取沪深300成分股的 alpha_001 因子值
>>> a = alpha_001('2017-03-10','000300.XSHG')

# 查看前5行的因子值
>>> a.head()
000001.XSHE   -0.496667
000002.XSHE    0.226667
000008.XSHE   -0.043333
000009.XSHE   -0.093333
000027.XSHE   -0.030000
Name: rank_value_boolean, dtype: float64

# 查看平安银行的因子值
>>> a['000001.XSHE']
-0.49666666666666665

# 获取所有股票 alpha_007 的因子值
>>> a = alpha_007('2014-10-22')
# 查看欣旺达(300207)的因子值
>>> a['300207.XSHE']
0.8

# 查询函数说明
>>> alpha_101?
Type:        cython_function_or_method
String form: <cyfunction alpha_101 at 0x7f037a0167d0>
Docstring:
公式：
((close - open) / ((high - low) + .001))

Inputs:
    enddate: 查询日期
    index: 股票池

Outputs:
    因子的值
Alpha 191 因子
因子来源

根据国泰君安数量化专题研究报告 - 基于短周期价量特征的多因子选股体系给出了 191 个短周期交易型阿尔法因子，方便大家使用。

详细介绍

函数计算公式、API 调用方法，输入输出值详情请见:数据 - Alpha 191.

使用方法

# 导入 Alpha191 库
>>> from jqlib.alpha191 import *

# 获取所有股票 alpha_007 的因子值
>>>end_date = '2017-04-04'
>>>code = list(get_all_securities(['stock'],date=end_date).index)
>>> a = alpha_007(code,end_date)
# 查看欣旺达(300207)的因子值
>>> a['300207.XSHE']
1.2494895018526142

# 查询函数说明
>>> alpha_001?
Signature: alpha_001(code, end_date=None)
Docstring:
公式：
    (-1 * CORR(RANK(DELTA(LOG(VOLUME),1)),RANK(((CLOSE-OPEN)/OPEN)),6)
Inputs:
    code: 股票池
    end_date: 查询日期
Outputs:
    因子的值
File:      ~/alpha191.py
Type:      function
技术分析指标
因子说明 为了让用户有更多可直接调用的技术分析指标因子，我们计划基于通达信、东方财富、同花顺等的公式，来完善我们的技术分析指标因子库。

我们给出了公式的API、参数说明、返回值的结果及类型说明、备注（相较于上述三家结果及算法的比对）、用法注释及示例，旨在帮助您更方便、更快速的在策略研究中使用这些因子函数。

详细介绍 函数计算公式、API 调用方法，用法注释， 输入输出值详情请见:数据 - 技术分析指标.

使用方法

# 导入技术分析指标库
>>> from jqlib.technical_analysis import *

# 定义股票池列表
security_list1 = '000001.XSHE'
security_list2 = ['000001.XSHE','000002.XSHE','601211.XSHG','603177.XSHG']


# 计算并输出 security_list1 的 GDX 值，分别返回：济安线、压力线和支撑线的值。
gdx_jax, gdx_ylx, gdx_zcx = GDX(security_list1,check_date='2017-01-04', N = 30, M = 9)
print gdx_jax[security_list1]
print gdx_ylx[security_list1]
print gdx_zcx[security_list1]

# 输出 security_list2 的 GDX 值
gdx_jax, gdx_ylx, gdx_zcx = GDX(security_list2,check_date='2017-01-04', N = 30, M = 9)
for stock in security_list2:
    print gdx_jax[stock]
    print gdx_ylx[stock]
    print gdx_zcx[stock]

# 查询函数说明
>>> GDX?
Signature: GDX(security_list, check_date, N=30, M=9)
Docstring:
 计算公式：
    AA:=ABS((2*CLOSE+HIGH+LOW)/4-MA(CLOSE,N))/MA(CLOSE,N); 
    JAX:DMA(CLOSE,AA);
    压力线:(1+M/100)*JAX; 
    支撑线:(1-M/100)*JAX; 
    AA赋值:(2*收盘价+最高价+最低价)/4-收盘价的N日简单移动平均的绝对值/收盘价的N日简单移动平均
    输出济安线 = 以AA为权重收盘价的动态移动平均
    输出压力线 = (1+M/100)*JAX
    输出支撑线 = (1-M/100)*JAX
输入：
    security_list:股票列表
    check_date：要查询数据的日期
    N：统计的天数 N
    M：统计的天数 M
输出：
    济安线、压力线和支撑线的值。
输出结果类型：
    字典(dict)：键(key)为股票代码，值(value)为数据。
下单函数
提示：所有下单函数可以在 handle_data中 与 定时运行函数 的 time 参数为 "every_bar", "open", "morning", "night" 时使用。

可能的失败原因:

股票数量经调整后变成0 (请看下面的说明)
股票停牌
股票未上市或者退市
股票不存在
为股票、基金开了空单
选择了不存在的仓位号，如没有建立多个仓位，而设定pindex的数大于0
对于原因4, 我们会抛出异常停止运行, 因为我们认为这是您代码的bug.

注意:

因为下列原因, 有时候实际买入或者卖出的股票数量跟您设置的不一样，这个时候我们会在您的log中添加警告信息。
买入时会根据您当前的现金来限制您买入的数量
卖出时会根据您持有股票的数量来限制您卖出的数量
我们会遵守A股交易规则: 每次交易数量只能是100的整数倍, 但是卖光所有股票时不受这个限制
根据交易所规则, 每天结束时会取消所有未完成交易


order - 按股数下单
order(security, amount, style=None, side='long', pindex=0, close_today=False)
买卖标的。调用成功后, 您将可以调用[get_open_orders]取得所有未完成的交易, 也可以调用[cancel_order]取消交易

参数

security: 标的代码
amount: 交易数量, 正数表示买入, 负数表示卖出
style: 参见[order styles], None代表MarketOrder
side: 'long'/'short'，操作多单还是空单。默认为多单，股票、基金暂不支持开空单。
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0 指定第一个 subportfolio, 1 指定第二个 subportfolio，默认为0。
close_today: 平今字段。
close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓
close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓
close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错
返回 Order对象或者None, 如果创建订单成功, 则返回Order对象, 失败则返回None

示例

#买入平安银行股票100股
order('000001.XSHE', 100) # 下一个市价单
order('000001.XSHE', 100, MarketOrderStyle()) # 下一个市价单, 功能同上
order('000001.XSHE', 100, LimitOrderStyle(10.0)) # 以10块价格下一个限价单
order_target - 目标股数下单
order_target(security, amount, style=None, side='long', pindex=0, close_today=False)
买卖标的, 使最终标的的数量达到指定的amount

参数

security: 标的代码
amount: 期望的最终数量
style: 参见[order styles], None代表MarketOrder
side: 'long'/'short'，操作多单还是空单。默认为多单，股票、基金暂不支持开空单。
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
close_today: 平今字段。
close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓
close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓
close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错
返回 Order对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None

示例

# 卖出平安银行所有股票
order_target('000001.XSHE', 0)
# 买入平安银行所有股票到100股
order_target('000001.XSHE', 100)
order_value - 按价值下单
order_value(security, value, style=None, side='long', pindex=0, close_today=False)
买卖价值为value的标的。

参数

security: 股票名字
value: 股票价值
style: 参见[order styles], None代表MarketOrder
side: 'long'/'short'，操作多单还是空单。默认为多单，股票、基金暂不支持开空单。
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
close_today: 平今字段。
close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓
close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓
close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错
返回 Order对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None

示例

#卖出价值为10000元的平安银行股票
order_value('000001.XSHE', -10000)
#买入价值为10000元的平安银行股票
order_value('000001.XSHE', 10000)
order_target_value - 目标价值下单
order_target_value(security, value, style=None, side='long', pindex=0, close_today=False)
调整标的仓位到value价值。

参数

security: 标的名字
value: 期望的标的最终价值
style: 参见[order styles], None代表MarketOrder
side: 'long'/'short'，操作多单还是空单。默认为多单，股票、基金暂不支持开空单。
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
close_today: 平今字段。
close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓
close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓
close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错
返回 Order对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None

示例

#卖出平安银行所有股票
order_target_value('000001.XSHE', 0)
#调整平安银行股票仓位到10000元价值
order_target_value('000001.XSHE', 10000)
cancel_order - 撤单
cancel_order(order)
取消订单

参数

order: [Order]对象或者order_id
返回 Order对象或者None, 如果取消委托成功, 则返回Order对象, 委托不存在返回None

示例

#每个交易日结束运行
def after_trading_end(context):
    # 得到当前未完成订单
    orders = get_open_orders()
    # 循环，撤销订单
    for _order in orders.values():
        cancel_order(_order)
get_open_orders - 获取未完成订单
get_open_orders()
获得当天的所有未完成的订单

参数 无

返回 返回一个dict, key是order_id, value是[Order]对象

示例

#每个交易日结束运行
def after_trading_end(context):
    #得到当前未完成订单
    orders = get_open_orders()
    for _order in orders.values():
        log.info(_order.order_id)
get_orders - 获取订单信息
get_orders(order_id=None, security=None, status=None)
获取当天的所有订单

参数

order_id: 订单 id
security: 标的代码，可以用来查询指定标的的所有订单
status: [OrderStatus]， 查询特定订单状态的所有订单
返回 返回一个dict, key是order_id, value是[Order]对象

示例

#每个交易日结束运行
def after_trading_end(context):
    #得到当天所有订单
    orders = get_orders()
    for _order in orders.values():
        log.info(_order.order_id)

    # 根据订单id查询订单
    get_orders(order_id='1517627499')   

    # 查询所有标的为 000002.XSHE 的订单
    get_orders(security='000002.XSHE')  

    # 查询订单状态为 OrderStatus.held 的所有订单
    get_orders(status=OrderStatus.held)

    # 查询标的为 000002.XSHE 且状态为 OrderStatus.held 的所有订单
    get_orders(security='000002.XSHE', status=OrderStatus.held)
get_trades - 获取成交信息
get_trades()
获取当天的所有成交记录, 一个订单可能分多次成交

参数 无

返回 返回一个dict, key是trade_id, value是[Trade]对象

示例

#每个交易日结束运行
def after_trading_end(context):
    #得到当天所有成交记录
    trades = get_trades()
    for _trade in trades.values():
        log.info(_trade.trade_id)
inout_cash - 账户出入金
inout_cash(cash, pindex=0)
账户转入或转出资金，当日的出入金从当日开始记入成本，用于计算收益，即当日结束计算收益时的本金是包含当日出入金金额的；

参数

cash 可正可负，正为入金，负为出金。
pindex 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
示例

# 查看账户可用资金
log.info('账户可用资金：',context.portfolio.subportfolios[0].available_cash)
# 增加资金：6666
inout_cash(6666, pindex=0)
# 查看增加资金之后账户的可用资金
log.info('账户可用资金：',context.portfolio.subportfolios[0].available_cash)
其他函数
定时运行 ♠
run_monthly
run_weekly
run_daily
def initialize(context):
    # 按月运行
    run_monthly(func, monthday, time='open', reference_security)
    # 按周运行
    run_weekly(func, weekday, time='open', reference_security)
    # 每天内何时运行
    run_daily(func, time='open', reference_security)
回测环境/模拟专用API

指定每月, 每周或者每天要运行的函数, 可以在具体每月/周的第几个交易日(或者倒数第几天)的某一分钟执行。

在日级模拟中使用时，如果设置 time='open' 或 time='9:30'，策略的实际运行时间是9:27~9:30之间。策略类获取到逻辑时间(context.current_dt)仍然是 9:30。 注意只有在使用相同的参照标的时，定时运行函数的优先级别为:run_monthly>run_weekly>run_daily且与函数被注册的顺序无关；handle_data与handle_tick的执行顺序与前述函数无关。用户策略不应该依赖于这些计划任务执行的顺序。

调用这些函数后, handle_data可以不实现

参数

参数	解释
func	一个函数, 此函数必须接受context参数
monthday	每月的第几个交易日, 可以是负数, 表示倒数第几个交易日。如果超出每月总交易日个数，则取临近的交易日执行。（具体见下方注意中的示例）
weekday	每周的第几个交易日, 可以是负数, 表示倒数第几个交易日。如果超出每周总交易日个数，则取临近的交易日执行。（具体见下方注意中的示例）
time	一个字符串,可以是具体执行时间,支持 time 表达式。比如 "10:00", "01:00", 或者 "every_bar", "open", "before_open", "after_close", "morning" 和 "night"。(具体执行时间如见下方)

time 表达式具有 'base +/-offset' 的形式，如：'open-30m'表示开盘前30分钟，'close+1h30m'表示收盘后一小时三十分钟。
reference_security	时间的参照标的。
如参照 '000001.XSHG'，交易时间为 9:30-15:00。
如参照'IF1512.CCFX'，2016-01-01之后的交易时间为 9:30-15:00，在此之前为 9:15-15:15。
如参照'A9999.XDCE'，因为有夜盘，因此开始时间为21:00，结束时间为15:00。
base	具体执行时间
具体时间	24小时内的任意时间，如"10:00", "01:00"
every_bar	只能在 run_daily 中调用； 按天会在每天的开盘时调用一次，按分钟会在每天的每分钟运行
open	开盘时运行(等同于"9:30")
before_open	早上 9:00 运行
after_close	下午 15:30 运行
morning	早上 8:00 运行
night	晚上 20:00 运行
返回值 None

注意

参数 func 必须是一个全局的函数, 不能是类的成员函数, 示例:
def on_week_start(context):
    pass

class MyObject(object):
    def on_week_start2(self, context):
        pass

def initialize(context):
    # OK
    run_weekly(on_week_start, 1)
    # 错误, 下面的语句会报错
    run_weekly(MyObject().on_week_start2, 1)
通过[history]/[attribute_history]取天数据时, 是不包括当天的数据的(即使在15:00和after_close里面也是如此), 要取得当天数据, 只能取分钟的
这些函数可以重复调用, 比如下面的代码可以在每周的第一个交易日和最后一个交易日分别调用两个函数:
def on_week_start(context):
    pass
def on_week_end(context):
    pass
def initialize(context):
    run_weekly(on_week_start, 1)
    run_weekly(on_week_end, -1)
每次调用这些函数都会产生一个新的定时任务, 如果想修改或者删除旧的定时任务, 请先调用 [unschedule_all] 来删除所有定时任务, 然后再添加新的.

在一月/一周交易日数不够以致于monthday/weekday无法满足时, 我们会找这周内最近的一个日期来执行, 比如, 如果某一周只有4个交易日:

若 weekday == 5, 我们会在第4个交易日执行
若 weekday == -5, 我们会在第1个交易日执行
如果要避免这样的行为, 您可以这样做:

def initialize(context):
    run_weekly(weekly, 1)

def weekly(context):
    if context.current_dt.isoweekday() != 1:
        # 不在周一, 跳过执行
        return
示例

def weekly(context):
    print 'weekly %s %s' % (context.current_dt, context.current_dt.isoweekday())


def monthly(context):
    print 'monthly %s %s' % (context.current_dt, context.current_dt.month)


def daily(context):
    print 'daily %s' % context.current_dt


def initialize(context):

    # 指定每月第一个交易日, 在开盘后十分钟执行
    run_monthly(monthly, 1, 'open+10m')

    # 指定每周倒数第一个交易日, 在开盘前执行
    run_weekly(weekly, -1, 'before_open')

    # 指定每天收盘前10分钟运行
    run_daily(daily, 'close - 10m')

    # 指定每天收盘后执行
    run_daily(daily, 'after_close')

    # 指定在每天的10:00运行
    run_daily(daily, '10:00')

    # 指定在每天的01:00运行
    run_daily(daily, '01:00')

    # 参照股指期货的时间每分钟运行一次, 必须选择分钟回测, 否则每天执行
    run_daily(daily, 'every_bar', reference_security='IF1512.CCFX')
取消所有定时运行 ♠
# 取消所有定时运行
unschedule_all()
画图函数record ♠
record(**kwargs)
回测环境/模拟专用API

我们会帮您在图表上画出收益曲线和基准的收益曲线，您也可以调用record函数来描画额外的曲线。 因为我们是按天展现的，如果您使用按分钟回测，我们画出的点是您最后一次调用record的值。

参数 很多key=>value形式的参数，key曲线名称，value为值

返回 None

示例

# d是一个SecurityUnitData结构体，会画出每个单元时间(天或分钟)的平均价,开始价,结束价
record(price=d.price, open=d.open, close=d.close)
# 也可以画一条100的直线
record(price=100)
发送自定义消息 ♠
send_message(message, channel='weixin')
回测环境/模拟专用API

给用户自己发送消息, 暂时只支持微信消息.

参数 message: 消息内容. 字符串. channel: 消息渠道, 暂时只支持微信: weixin. 默认值是 weixin

返回值 True/False, 表示是否发送成功. 当发送失败时, 会在日志中显示错误信息.

注意

要使用功能, 必须开启模拟交易的 微信通知.
此功能只能在 模拟交易 中使用, 回测中使用会直接忽略, 无任何提示.
微信消息每人每天不超过 5 条, 超出会失败.
微信消息主页只显示前 200 个字符, 点击详情可查看全部消息, 全部消息不得超过 10000 个字符.
示例

send_message("测试消息")
日志log
log.error(content)
log.warn(content)
log.info(content)
log.debug(content)
print content1, content2, ...
分级别打log,跟python的logging模块一致 print输出的结果等同于log.info, 但是print后面的每一个元素会占用一行

参数 参数可以是字符串、对象等

返回 None

示例

log.info(history(10)) # 打印出 history(10)返回的结果
log.info("Selling %s, amount=%s", security, amount) # 打印出一个格式化后的字符串
print history(10), data, context.portfolio
设定log级别：log.set_level
log.set_level(name, level)
设置不同种类的log的级别, 低于这个级别的log不会输出. 所有log的默认级别是debug

参数 name: 字符串, log种类, 必须是'order', 'history', 'strategy'中的一个, 含义分别是:

order: 调用order系列API产生的log
history: 调用history系列API(history/attribute_history/get_price)产生的log
strategy: 您自己在策略代码中打的log
system：系统日志，除以上三类之外的日志
level: 字符串, 必须是'debug', 'info', 'warning', 'error'中的一个, 级别: debug < info < warning < error

返回 None

示例

# 过滤掉order系列API产生的比error级别低的log
log.set_level('order', 'error')
write_file - 写文件
write_file(path, content, append=False)
写入内容到研究模块path文件, 写入后, 您可以立即在研究模块中看到这个文件

参数

path: 相对路径, 相对于您的私有空间的根目录的路径
content: 文件内容, str或者unicode, 如果是unicode, 则会使用UTF-8编码再存储.可以是二进制内容.
append: 是否是追加模式, 当为False会清除原有文件内容，默认为False.
返回 None 如果写入失败(一般是因为路径不合法), 会抛出异常

示例

write_file("test.txt", "hello world")

# 写入沪深300的股票到HS300.stocks.json文件中
import json
write_file('HS300.stocks.json', json.dumps(get_index_stocks('000300.XSHG')))

# 把 DataFrame 表保存到文件
df = attribute_history('000001.XSHE', 5, '1d') #获取DataFrame表
write_file('df.csv', df.to_csv(), append=False) #写到文件中

## 详细用法可以参考文档：https://www.joinquant.com/post/580
read_file - 读文件
read_file(path)
读取你的私有文件(您的私有文件可以在研究模块中看到)

参数 path: 相对路径, 相对于您的私有空间的根目录的路径

返回 返回文件的原始内容, 不做任何decode.

示例

#解析json文件
import json
content = read_file('HS300.stocks.json')
securities = json.loads(content)
log.info(securities)

#解析csv文件
import pandas as pd
from six import StringIO
body=read_file("open.csv")
data=pd.read_csv(StringIO(body))

## 详细用法可以参考文档：https://www.joinquant.com/post/580
自定义python库
您可以在把.py文件放在'研究'的根目录, 然后在回测中就可以通过import的方式来引用此文件. 比如

研究根目录/mylib.py:

#-*- coding: utf-8 -*-
# 如果你的文件包含中文, 请在文件的第一行使用上面的语句指定你的文件编码

# 用到回测API请加入下面的语句
from kuanke.user_space_api import *

my_stocks = get_index_stocks('000300.XSHG')
在策略代码中:

# 导入自己创建的库
from mylib import *

def initialize(context):
    log.info(my_stocks)
注意: 暂时只能import研究根目录下的.py文件, 还不能import子目录下的文件(比如通过 import a.b.c 来引用a/b/c.py)

研究中创建回测函数
create_backtest(algorithm_id, start_date, end_date, frequency="day", initial_cash=10000, initial_positions=None, extras=None, name=None, code="")
通过一个策略ID从研究中创建回测

参数：

algorithm_id: 策略ID，从策略编辑页的 url 中获取, 比如 '/algorithm/index/edit?algorithmId=xxxx'，则策略ID为 xxxx
start_date: 回测开始日期
end_date: 回测结束日期
frequency: 数据频率，支持 day，minute
initial_cash: 初始资金
extras: 额外参数，一个 dict， 用于设置全局的 g 变量，如 extras={'x':1, 'y':2}，则回测中 g.x = 1, g.y = 2，需要注意的是，该参数的值是在 initialize 函数执行之后才设置给 g 变量的，所以这会覆盖掉 initialize 函数中 g 变量同名属性的值
name: 回测名, 用于指定回测名称, 如果没有指定则默认采用策略名作为回测名
initial_positions: 初始持仓。持仓会根据价格换成现金加到初始资金中，如果没有给定价格则默认获取股票最近的价格。格式如下:
initial_positions = [
    {
        'security':'000001.XSHE',
        'amount':'100',
    },
    {
        'security':'000063.XSHE',
        'amount':'100',
        'avg_cost': '1.0'
    },
]
code：策略代码。现在支持从研究中传入策略代码进行回测。指定之后将使用传入的代码来创建回测。
benchmark: 为回测设置基准。默认为None，表示使用策略中原有set_benchmark设置的基准。若不为None，则表示使用当前传入的基准覆盖原策略的基准。benchmark支持的基准同set_benchmark
返回：

一个字符串, 即 backtest_id

示例一：

algorithm_id = "xxxx"
extra_vars = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
initial_positions = [
    {
        'security':'000001.XSHE',
        'amount':'100',
    },
    {
        'security':'000063.XSHE',
        'amount':'100',
        'avg_cost': '1.0'
    },
]

params = {
    "algorithm_id": algorithm_id,
    "start_date": "2015-10-01",
    "end_date": "2016-07-31",
    "frequency": "day",
    "initial_cash": "1000000",
    "initial_positions": initial_positions,
    "extras": extra_vars,
}

created_bt_id = create_backtest(**params)
print(created_bt_id)
示例二，在研究中指定回测用策略代码：

code = """
# 导入函数库
from jqdata import *

# 初始化函数，设定基准等等
def initialize(context):
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    # log.set_level('order', 'error')

    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')

    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') 
      # 开盘时运行
    run_daily(market_open, time='open', reference_security='000300.XSHG')
      # 收盘后运行
    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')

## 开盘前运行函数     
def before_market_open(context):
    # 输出运行时间
    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))

    # 给微信发送消息（添加模拟交易，并绑定微信生效）
    send_message('美好的一天~')

    # 要操作的股票：平安银行（g.为全局变量）
    g.security = '000001.XSHE'

## 开盘时运行函数
def market_open(context):
    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))
    security = g.security
    # 获取股票的收盘价
    close_data = attribute_history(security, 5, '1d', ['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.available_cash

    # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    if current_price > 1.01*MA5:
        # 记录这次买入
        log.info("价格高于均价 1%%, 买入 %s" % (security))
        # 用所有 cash 买入股票
        order_value(security, cash)
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 记录这次卖出
        log.info("价格低于均价, 卖出 %s" % (security))
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)

## 收盘后运行函数  
def after_market_close(context):
    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))
    #得到当天所有成交记录
    trades = get_trades()
    for _trade in trades.values():
        log.info('成交记录：'+str(_trade))
    log.info('一天结束')
    log.info('##############################################################')

"""


algorithm_id = "xxxx"
extra_vars = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
initial_positions = [
    {
        'security':'000001.XSHE',
        'amount':'100',
    },
    {
        'security':'000063.XSHE',
        'amount':'100',
        'avg_cost': '1.0'
    },
]

params = {
    "algorithm_id": algorithm_id,
    "start_date": "2015-10-01",
    "end_date": "2016-07-31",
    "frequency": "day",
    "initial_cash": "1000000",
    "initial_positions": initial_positions,
    "extras": extra_vars,
}

created_bt_id = create_backtest(code=code, **params)
研究中获取回测与模拟交易信息
gt = get_backtest(backtest_id)
参数：

backtest_id: 回测ID，从回测详情页以及模拟交易详情页的 url 中获取, 比如 '/algorithm/backtest/detail?backtestId='以及'/algorithm/live/index?backtestId='，则回测ID为 xxxx。如下图所示：


返回：

gt.get_status():获取回测状态. 返回一个字符串，其含义分别为：
none: 未开始
running: 正在进行
done: 完成
failed: 失败
canceled: 取消
paused: 暂停
deleted: 已删除
gt.get_params()：获得回测参数. 返回一个 dict, 包含调用 create_backtest 时传入的所有信息. (注： algorithm_id，initial_positions，extras 只有在研究中创建的回测才能取到)
gt.get_results()：获得收益曲线. 返回一个 list，每个交易日是一个 dict，键的含义如下：
time: 时间
returns: 收益
benchmark_returns: 基准收益
如果没有收益则返回一个空的 list
gt.get_positions()：获得持仓详情. 返回一个 list，每个交易日为一个 dict，键的含义为：
time: 时间
security: 证券代码
security_name: 证券名称
amount: 持仓数量
price: 股票价格
avg_cost: 买入股票平均每股所花的钱
closeable_amount: 可平仓数量
如果没有持仓则返回一个空的 list
gt.get_orders()：获得交易详情. 返回一个 list，每个交易日为一个 dict，键的含义为：
time: 时间
security: 证券代码
security_name: 证券名称
action: 交易类型, 开仓('open')/平仓('close')
amount: 下单数量
filled: 成交数量
price: 平均成交价格
commission: 交易佣金
如果没有持仓则返回一个空的 list
gt.get_records()：获得所有 record 记录. 返回一个 list，每个交易日为一个 dict，键是 time 以及调用 record() 函数时设置的值.
gt.get_risk()：获得总的风险指标. 返回一个 dict，键是各类收益指标数据，如果没有风险指标则返回一个空的 dict.
gt.get_period_risks()：获得分月计算的风险指标. 返回一个 dict，键是各类指标, 值为一个 pandas.DataFrame. 如果没有风险指标则返回一个空的 dict.
示例：

gt = get_backtest("xxxx")

gt.get_status()        # 获取回测状态
gt.get_params()        # 获取回测参数
gt.get_results()       # 获取收益曲线
gt.get_positions()     # 获取所有持仓列表
gt.get_orders()        # 获取交易列表
gt.get_records()       # 获取所有record()记录
gt.get_risk()          # 获取总的风险指标
gt.get_period_risks()  # 获取分月计算的风险指标
股票代码格式转换
normalize_code()
将其他形式的股票代码转换为聚宽可用的股票代码形式。

仅适用于A股市场股票代码以及基金代码

示例

#输入
for code in ('000001', 'SZ000001', '000001SZ', '000001.sz', '000001.XSHE'):
        print normalize_code(code)

#输出
000001.XSHE
000001.XSHE
000001.XSHE
000001.XSHE
000001.XSHE
性能分析 ♠
enable_profile()
回测环境/模拟专用API

开启性能分析功能, 请在所有代码之前调用这句话(即在策略编译页面的代码编辑框最上方放置该代码), 只在点击 '运行回测' 运行的时候才能看到性能分析结果. 开启性能分析之后, 你会在回测结果页面看到性能分析结果. 请注意, 不需要时, 请不要调用此函数, 因为它本身会影响程序性能.

结果示例(真实输出中没有中文说明):

// 时间单位: 微秒
Timer unit: 1e-06 s

// 函数执行总时间
Total time: 0.00277 s
// 文件名
File: user_code.py
// 函数名
Function: initialize at line 3

//  行号, 这一行执行次数,总执行时间,每次执行时间, 这一行执行时间在整个函数的比例
Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           def initialize(context):
     4                                               # 定义一个全局变量, 保存要操作的股票
     5                                               # 000001(股票:平安银行)
     6         1           31     31.0      1.1      g.security = '000001.XSHE'
     7                                               # 初始化此策略
     8                                               # 设置我们要操作的股票池, 这里我们只操作一支股票
     9         1         2739   2739.0     98.9      set_universe([g.security])

Total time: 0.426325 s
File: user_code.py
Function: handle_data at line 12

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    12                                           def handle_data(context, data):
    13       122          398      3.3      0.1      security = g.security
    14                                               # 取得过去五天的平均价格
    15       122       168565   1381.7     39.5      average_price = data[security].mavg(5)
    16                                               # 取得上一时间点价格
    17       122          493      4.0      0.1      current_price = data[security].price
    18                                               # 取得当前的现金
    19       122          240      2.0      0.1      cash = context.portfolio.cash
    20
    21                                               # 如果上一时间点价格高出五天平均价1%, 则全仓买入
    22       122          396      3.2      0.1      if current_price > 1.01*average_price:
    23                                                   # 计算可以买多少只股票
    24        30          124      4.1      0.0          number_of_shares = int(cash/current_price)
    25                                                   # 购买量大于0时，下单
    26        30           56      1.9      0.0          if number_of_shares > 0:
    27                                                       # 买入股票
    28        30        83190   2773.0     19.5              order(security, +number_of_shares)
    29                                                       # 记录这次买入
    30        30        16202    540.1      3.8              log.info("Buying %s" % (security))
    31                                               # 如果上一时间点价格低于五天平均价, 则空仓卖出
    32        92         1119     12.2      0.3      elif current_price < average_price and context.portfolio.positions[security].amount > 0:
    33                                                   # 卖出所有股票,使这只股票的最终持有量为0
    34        13        86702   6669.4     20.3          order_target(security, 0)
    35                                                   # 记录这次卖出
    36        13         8210    631.5      1.9          log.info("Selling %s" % (security))
    37                                               # 画出上一时间点价格
    38       122        60630    497.0     14.2      record(stock_price=data[security].price)
对象
全局对象 g
全局对象 g，用来存储用户的各类可被[pickle.dumps]函数序列化的全局数据

在模拟盘中，如果中途进程中断，我们会使用[pickle.dumps]序列化所有的g下面的变量内容, 保存到磁盘中，再启动的时候模拟盘就不会有任何数据影响。如果没有用g声明，会出现模拟盘重启后，变量数据丢失的问题。

如果不想 g 中的某个变量被序列化, 可以让变量以 '__' 开头, 这样, 这个变量在序列化时就会被忽略

更多模拟盘细节, 请看 模拟盘注意事项.

def initialize(context):
    g.security = "000001.XSHE"
    g.count = 1
    g.flag = 0

def process_initialize(context):
    # 保存不能被序列化的对象, 进程每次重启都初始化, 更多信息, 请看 [process_initialize]
    g.__q = query(valuation)

def handle_data(context, data):
    log.info(g.security)
    log.info(g.count)
    log.info(g.flag)
全局对象 g，用来存储用户的各类可被[pickle.dumps]函数序列化的全局数据

在模拟盘中，如果中途进程中断，我们会使用[pickle.dumps]序列化所有的g下面的变量内容, 保存到磁盘中，再启动的时候模拟盘就不会有任何数据影响。如果没有用g声明，会出现模拟盘重启后，变量数据丢失的问题。

如果不想 g 中的某个变量被序列化, 可以让变量以 '__' 开头, 这样, 这个变量在序列化时就会被忽略

更多模拟盘细节, 请看 模拟盘注意事项.

def initialize(context):
    g.security = "000001.XSHE"
    g.count = 1
    g.flag = 0

def process_initialize(context):
    # 保存不能被序列化的对象, 进程每次重启都初始化, 更多信息, 请看 [process_initialize]
    g.__q = query(valuation)

def handle_data(context, data):
    log.info(g.security)
    log.info(g.count)
    log.info(g.flag)
Context
subportfolios: 当前单个操作仓位的资金、标的信息，是一个SubPortfolio 的数组

portfolio: 账户信息，即subportfolios 的汇总信息, Portfolio对象，单个操作仓位时，portfolio 指向 subportfolios[0]

current_dt: 当前单位时间的开始时间, [datetime.datetime]对象,

按天回测时, hour = 9, minute = 30, second = microsecond = 0,
按分钟回测时, second = microsecond = 0
previous_date: 前一个交易日, [datetime.date]对象, 注意, 这是一个日期, 是 date, 而不是 datetime

universe: 查询set_universe()设定的股票池, 比如: ['000001.XSHE', '600000.XSHG']

run_params: 表示此次运行的参数, 有如下属性

start_date: 回测/模拟开始日期, [datetime.date]对象
end_date: 回测/模拟结束日期, [datetime.date]对象
type: 运行方式, 如下四个字符串之一
'simple_backtest': 回测, 通过点击'编译运行'运行
'full_backtest': 回测, 通过点击'运行回测'运行
'sim_trade': 模拟交易
'live_trade': 实盘交易
frequency: 运行频率, 如下三个字符串之一
'day'
'minute'
'tick'
为了让从其他平台迁移过来的同学更顺手的使用系统, 我们对此对象也做了和 [g] 一样的处理:

可以添加自己的变量, 每次进程关闭时持久保存, 进程重启时恢复.
以 '__' 开头的变量不会被持久保存
如果添加的变量与系统的冲突, 将覆盖掉系统变量, 如果想恢复系统变量, 请删除自己的变量. 示例:
def handle_data(context, data):
    # 执行下面的语句之后, context.portfolio 的整数 1
    context.portfolio = 1
    log.info(context.portfolio)
    # 要恢复系统的变量, 只需要使用下面的语句即可
    del context.portfolio
    # 此时, context.portfolio 将变成账户信息.
    log.info(context.portfolio.portfolio_value)
- 我们以后可能会往 context 添加新的变量来支持更多功能, 为了减少不必要的迷惑, 还是建议大家使用 [g]
示例

def handle_data(context, data):

    #获得当前回测相关时间
    year = context.current_dt.year
    month = context.current_dt.month
    day = context.current_dt.day
    hour = context.current_dt.hour
    minute = context.current_dt.minute
    second = context.current_dt.second
    #得到"年-月-日"格式
    date = context.current_dt.strftime("%Y-%m-%d")
    #得到周几
    weekday = context.current_dt.isoweekday()

    # 获取账户的持仓价值
    positions_value = context.portfolio.positions_value

    # 获取仓位subportfolios[0]的可用资金
    available_cash = context.subportfolios[0].available_cash

    # 获取subportfolios[0]中多头仓位的security的持仓成本
    hold_cost = context.subportfolios[0].long_positions[security].hold_cost
SubPortfolio
某个仓位的资金，标的信息，如未使用 SubPortfolioConfig 设置多仓位，默认只有subportfolios[0]一个仓位，Portfolio 指向该仓位。

inout_cash: 累计出入金, 比如初始资金 1000, 后来转移出去 100, 则这个值是 1000 - 100
available_cash: 可用资金, 可用来购买证券的资金
transferable_cash: 可取资金, 即可以提现的资金, 不包括今日卖出证券所得资金
locked_cash: 挂单锁住资金
type: 账户所属类型
long_positions: 多单的仓位, 一个 dict, key 是证券代码, value 是 [Position]对象
short_positions: 空单的仓位, 一个 dict, key 是证券代码, value 是 [Position]对象
positions_value: 持仓价值
total_value: 总资产, 包括现金, 保证金, 仓位的总价值, 可用来计算收益
total_liability: 总负债, 等于融资负债、融券负债、利息总负债的总和
net_value: 净资产, 等于总资产减去总负债
cash_liability: 融资负债
sec_liability: 融券负债
interest: 利息总负债
maintenance_margin_rate: 维持担保比例
available_margin: 融资融券可用保证金
margin: 保证金，股票、基金保证金都为100%；融资融券保证金为0；期货保证金会实时更新, 总是等于当前期货价值 乘以 保证金比率, 当保证金不足时, 强制平仓. 平仓顺序是: 亏损多的(相对于开仓均价)先平仓
Portfolio
账户当前的资金，标的信息，即所有标的操作仓位的信息汇总。如未使用 SubPortfolioConfig 设置多仓位，默认只有subportfolios[0]一个仓位，Portfolio 指向该仓位。

inout_cash: 累计出入金, 比如初始资金 1000, 后来转移出去 100, 则这个值是 1000 - 100
available_cash: 可用资金, 可用来购买证券的资金
transferable_cash: 可取资金, 即可以提现的资金, 不包括今日卖出证券所得资金
locked_cash: 挂单锁住资金
margin: 保证金，股票、基金保证金都为100%
positions: 等同于 long_positions
long_positions: 多单的仓位, 一个 dict, key 是证券代码, value 是 [Position]对象
short_positions: 空单的仓位, 一个 dict, key 是证券代码, value 是 [Position]对象
total_value: 总的权益, 包括现金, 保证金, 仓位的总价值, 可用来计算收益
returns: 总权益的累计收益
starting_cash: 初始资金, 现在等于 inout_cash
positions_value: 持仓价值
locked_cash_by_purchase: 基金申购未完成所冻结的金额
locked_cash_by_redeem: 基金赎回未到账的金额
locked_amount_by_redeem: 基金赎回时，冻结的份额
cash: 已过时，等价于 available_cash
portfolio_value: 已过时，等价于 total_value
unsell_positions: 已过时, 请使用 positions 代替, 当前持有的不可以卖出的持仓(比如在A股T+1市场, 今天购票的股票), 并没有考虑股票今天是否停牌, 一个dict, key是股票代码, value是[Position]对象.
Position
持有的某个标的的信息

security: 标的代码
price: 最新行情价格
acc_avg_cost: 累计开仓成本,计算方法如下 买入: (old_amount * old_avg_cost + trade_amount * trade_price + commission) / (old_amount + trade_amount) 卖出: (old_amount * old_avg_cost - trade_amount * trade_price + commission) / (old_amount - trade_amount)
avg_cost: 开仓均价，买入标的的加权平均价, 计算方法是: (buy_volume1 * buy_price1 + buy_volume2 * buy_price2 + …) / (buy_volume1 + buy_volume2 + …) 每次买入后会调整avg_cost, 卖出时avg_cost不变. 这个值也会被用来计算浮动盈亏.
hold_cost: 持仓成本，针对期货有效。
init_time: 建仓时间，格式为 datetime.datetime
transact_time: 最后交易时间，格式为 datetime.datetime
total_amount: 总仓位, 但不包括挂单冻结仓位
closeable_amount: 可卖出的仓位 / 场外基金持有份额
today_amount: 今天开的仓位
locked_amount: 挂单冻结仓位
value: 标的价值，计算方法是: price * total_amount * multiplier, 其中股票、基金的multiplier为1，期货为相应的合约乘数
side: 多/空，'long' or 'short'
pindex: 仓位索引，subportfolio index
sellable_amount: 已过时, 为了向前兼容, 等同于 closeable_amount
amount: 已过时, 为了向前兼容, 等同于 closeable_amount
SecurityUnitData
一个单位时间内的股票的数据

基本属性
以下属性也能通过[history]/[attribute_history]/[get_price]获取到

open: 时间段开始时价格
close: 时间段结束时价格
low: 最低价
high: 最高价
volume: 成交的股票数量
money: 成交的金额
factor: 前复权因子, 我们提供的价格都是前复权后的, 但是利用这个值可以算出原始价格, 方法是价格除以factor, 比如: close/factor
high_limit: 涨停价
low_limit: 跌停价
avg: 这段时间的平均价, 等于money/volume
~~price: 已经过时, 为了向前兼容, 等同于 avg~~
pre_close: 前一个单位时间结束时的价格, 按天则是前一天的收盘价, 按分钟则是前一分钟的结束价格
paused: bool值, 这只股票是否停牌, 停牌时open/close/low/high/pre_close依然有值,都等于停牌前的收盘价, volume=money=0
额外的属性和方法
security: 股票代码, 比如'000001.XSHE'
returns: 股票在这个单位时间的相对收益比例, 等于 (close-pre_close)/pre_close
isnan(): 数据是否有效, 当股票未上市或者退市时, 无数据, isnan()返回True
mavg(days, field='close'): 过去days天的每天收盘价的平均值, 把field设成'avg'(等同于已过时的'price')则为每天均价的平均价, 下同
vwap(days): 过去days天的每天均价的加权平均值, 以days=2为例子, 算法是:
(avg1 * volume1 + avg2 * volume2) / (volume1 + volume2)
stddev(days): 过去days天的每天收盘价的标准差
注：mavg/vwap/stddev:都会跳过停牌日期, 如果历史交易天数不足, 则返回nan
tick 对象
一个 tick 所包含的信息。 tick 中的信息是在 tick 事件发生时， 盘面的一个快照。

code: 标的的代码
datetime: tick 发生的时间
current: 最新价
high: 截至到当前时刻的最高价
low: 截至到当前时刻的最低价
volume: 截至到当前时刻的成交量
money: 截至到当前时刻的成交额
position: 截至到当前时刻的持仓量，只适用于期货 tick 对象
a1_v ~ a5_v: 卖一量到卖五量，对于期货，只有卖一量
a1_p ~ a5_p: 卖一价到卖五价，对于期货，只有卖一量
b1_v ~ b5_v: 买一量到买五量，对于期货，只有买一量
b1_p ~ b5_p: 买一价到买五价，对于期货，只有买一价
Trade对象
订单的一次交易记录,一个订单可能分多次交易.

time: 交易时间, [datetime.datetime]对象
security：标的代码
amount: 交易数量
price: 交易价格
trade_id: 交易记录id
order_id: 对应的订单id
Order对象
买卖订单

status: 状态, 一个[OrderStatus]值
add_time: 订单添加时间, [datetime.datetime]对象
is_buy: bool值, 买还是卖，对于期货:
开多/平空 -> 买
开空/平多 -> 卖
amount: 下单数量, 不管是买还是卖, 都是正数
filled: 已经成交的股票数量, 正数
security: 股票代码
order_id: 订单ID
price: 平均成交价格, 已经成交的股票的平均成交价格(一个订单可能分多次成交)
avg_cost: 卖出时表示下卖单前的此股票的持仓成本, 用来计算此次卖出的收益. 买入时表示此次买入的均价(等同于price).
side: 多/空，'long'/'short'
action: 开/平， 'open'/'close'
OrderStatus - 订单状态
订单状态, Enum特性使用的第三方库(https://pypi.python.org/pypi/enum34)

class OrderStatus(Enum):
    # 订单新创建未委托，用于盘前/隔夜单，订单在开盘时变为 open 状态开始撮合
    new = 8

    # 订单未完成, 无任何成交
    open = 0

    # 订单未完成, 部分成交
    filled = 1

    # 订单完成, 已撤销, 可能有成交, 需要看 Order.filled 字段
    canceled = 2

    # 订单完成, 交易所已拒绝, 可能有成交, 需要看 Order.filled 字段
    rejected = 3

    # 订单完成, 全部成交, Order.filled 等于 Order.amount
    held = 4

    # 订单取消中，只有实盘会出现，回测/模拟不会出现这个状态
    pending_cancel = 9 
OrderStyle - 下单方式
下单方式, 有如下子类

市价单: 不论价格, 直接下单, 直到交易全部完成
class MarketOrderStyle(OrderStyle):
    pass
限价单: 指定一个价格, 买入时不能高于它, 卖出时不能低于它, 如果不满足, 则等待满足后再交易
class LimitOrderStyle(OrderStyle):
    def __init__(self, limit_price):
        self.limit_price = limit_price
策略组合操作
初始化仓位 subportfolios
set_subportfolios([SubPortfolioConfig(cash,type), ... ])
初始化或者修改 subportfolios 的配置，只能在 initialize 中调用, 每个 SubPortfolioConfig 中 cash 的和应该等于总的初始资金

SubPortfolioConfig 参数

SubPortfolioConfig(cash,type)
cash: 仓位初始资金
type: 可操作标的的类型，'stock' / 'index_futures' / 'futures' / 'stock_margin', 其中 stock 包括股票和基金，index_futures 指金融期货，futures 包含股指期货和商品期货，stock_margin 为融资融券账户。
示例

init_cash = 500000 # 定义一个变量
# 设定subportfolios[0]为 股票和基金仓位，初始资金为 init_cash 变量代表的数值
# 设定subportfolios[1]为 金融期货仓位，初始资金为 init_cash 变量代表的数值
# 设定subportfolios[2]为 融资融券账户，初始资金为 init_cash 变量代表的数值
set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock'),\
                   SubPortfolioConfig(cash=init_cash, type='futures'),\
                   SubPortfolioConfig(cash=init_cash, type='stock_margin')])
SubPortfolio 子仓位
某个仓位的资金，标的信息，如不使用 SubPortfolioConfig 设置多仓位，默认只有subportfolios[0]一个仓位，Portfolio 指向该仓位。每个策略最多可以创建100个 subportfolio。

有关 SubPortfolio 详情见对象 - SubPortfolio

仓位间转移资金
transfer_cash(from_pindex, to_pindex, cash)
从序号为 from_pindex 的 subportfolio 转移 cash 到序号为 to_pindex 的 subportfolio 资金转移及时到账

Tick 级策略专用函数
Tick级回测模拟需要申请才能使用，申请链接

Tick级回测模拟需要申请才能使用，申请链接

注意Tick级回测必须使用真实价格模式，设置方式详见设置真实价格模式

股票部分， 支持 2017-01-01 至今的tick数据，提供买五卖五数据。

期货部分， 支持 2010-01-01 至今的tick数据，提供买一卖一数据。

handle_tick
handle_tick(context, tick)
该函数在策略订阅的标的产生 tick 事件时被调用一次。如果没有 tick 事件， 则不会被调用。

参数

context: context 对象, 存放有当前的账户/标的持仓信息
tick: tick 对象， 存放了触发 handle_tick 事件的 tick 数据。
返回

None
示例

def handle_tick(context, tick):
    log.info(tick)
subscribe - 订阅标的的 tick 事件
 subscribe(security, frequency)
订阅标的的 tick 事件， 必须在频率为 tick 的回测、模拟中使用。

参数

security：要订阅的标的代码或代码列表。目前支持订阅股票、商品期货和股指期货，不能直接订阅主力合约、指数合约代码。 每个策略，回测中不限订阅标的数量，模拟交易时中最多可同时订阅100个标的。
frequency：目前必须使用'tick'
unsubcribe - 取消订阅标的的 tick 事件
unsubscribe(security, frequency)
取消订阅标的的 tick 事件

参数

security：要取消订阅的标的代码或代码列表。
frequency：目前必须使用'tick'
unsubscribe_all - 取消订阅所有 tick 事件
unsubscribe_all()
取消订阅所有 tick 事件

get_current_tick - 获取最新的 tick 数据
get_current_tick(security)
参数

security: 标的代码， 支持股票、商品期货和股指期货。 不可以使用主力合约和指数合约代码。
返回 tick 对象

get_ticks-获取股票和期货tick数据
get_ticks(security, end_dt, start_dt=None, count=None, fields=['time', 'current', 'high', 'low', 'volume', 'money'])
股票部分， 支持 2017-01-01 至今的tick数据，提供买五卖五数据。

期货部分， 支持 2010-01-01 至今的tick数据，提供买一卖一数据。 如果要获取主力合约的tick数据，可以先使用get_dominant_future(underlying_symbol,dt)获取主力合约对应的标的，然后再用get_ticks()获取该合约的tick数据

参数：

security: 股票代码或期货代码
end_dt: 结束日期
start_dt: 开始日期, 与count参数二选一
count: 取出指定时间区间内前多少条的tick数据, 与start_dt参数二选一
fields: 选择要获取的行情数据字段，默认为["time", "current", "high", "low", "volume", "money"]
返回值

一个numpy.ndarray。ndarray打印输出没有附带字段名，但您仍然可以通过array[field]的形式获取对应字段的数据。

股票tick返回结果
字段名	说明	字段类型
time	时间	float
current	当前价	float
high	最高价	float
low	最低价	float
volume	累计成交量	float
money	累计成交额	float
a1_v~a5_v	五档卖量	float
a1_p~a5_p	五档卖价	float
b1_v~b5_v	五档买量	float
b1_p~b5_v	五档买价	float
期货tick返回结果：
字段名	说明	字段类型
time	时间	float
current	当前价	float
high	最高价	float
low	最低价	float
volume	累计成交量	float
money	累计成交额	float
position	持仓量	float
a1_v	一档卖量	float
a1_p	一档卖价	float
b1_v	一档买量	float
b1_p	一档买价	float
股票tick数据示例：

#获取平安银行2018-07-03的tick数据，start_dt和count只能有一个不为None值
d = get_ticks("000001.XSHE",start_dt=None, end_dt="2018-07-03", count=10)
print(d)

[(20180702145636.0, 8.61, 9.05, 8.56, 1282514.0, 1130125956.0)
 (20180702145639.0, 8.6199, 9.05, 8.56, 1282536.0, 1130145028.0)
 (20180702145642.0, 8.6199, 9.05, 8.56, 1283323.0, 1130822660.0)
 (20180702145645.0, 8.6199, 9.05, 8.56, 1283486.0, 1130963076.0)
 (20180702145648.0, 8.61, 9.05, 8.56, 1283800.0, 1131233412.0)
 (20180702145651.0, 8.6199, 9.05, 8.56, 1284203.0, 1131580548.0)
 (20180702145654.0, 8.6199, 9.05, 8.56, 1284250.0, 1131620996.0)
 (20180702145657.0, 8.6199, 9.05, 8.56, 1284850.0, 1132138244.0)
 (20180702145700.0, 8.6199, 9.05, 8.56, 1285148.0, 1132395012.0)
 (20180702150003.0, 8.61, 9.05, 8.56, 1315520.0, 1158545922.0)]
期货tick数据示例：

#获取AU1812期货合约在2018-07-02的tick数据,start_dt和count只能有一个不为None值
>>>get_ticks('AU1812.XSGE',start_dt='2018-07-02',end_dt='2018-07-03',count=None)
[(20180702090000.0, 271.9, 272.45, 271.0, 44536.0, 12100317200.0)
 (20180702090001.0, 271.85, 272.45, 271.0, 44664.0, 12135122600.0)
 (20180702090001.5, 271.9, 272.45, 271.0, 44674.0, 12137841500.0) ...,
 (20180702235945.0, 272.05, 272.95, 272.0, 42986.0, 11717679600.0)
 (20180702235946.0, 272.05, 272.95, 272.0, 42994.0, 11719856000.0)
 (20180702235959.0, 272.05, 272.95, 272.0, 42998.0, 11720944200.0)]
Tick示例策略
示例1：
def initialize(context):
    init_cash = context.portfolio.starting_cash
    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='futures')])

    g.code1 = 'RB1802.XSGE'
    g.code2 = 'I1710.XDCE'
    subscribe(g.code1, 'tick')
    #subscribe(g.code2, 'tick')
    unsubscribe(g.code2, 'tick')
    unsubscribe_all()
    subscribe(g.code1, 'tick')

def handle_tick(context, tick):
    #pass
    log.info(tick)
    get_current_tick(g.code1)
    #order(g.code1, 1 , side='short', pindex=0)
示例2：
# 导入函数库
import jqdata
def initialize(context):
    set_benchmark('000300.XSHG')
    set_option('use_real_price', True)
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')

def before_trading_start(context):
    subscribe('000001.XSHE','tick')

def handle_tick(context, tick):
    log.info(tick)

def after_trading_end(context):
    unsubscribe_all()
融资融券专用函数
初始化融资融券账户
初始化的仓位是不允许直接进行融资融券操作的，因为初始默认 subportfolios[0] 中 SubPortfolioConfig 的 type = 'stock'，只允许买卖股票与基金等。

因此要进行融资融券，您需要设定 SubPortfolioConfig 的 type = 'stock_margin'，具体方法如下：

def initialize(context):

    ## 设置单个账户

    # 获取初始资金
    init_cash = context.portfolio.starting_cash 

    # 设定账户为融资融券账户，初始资金为 init_cash 变量代表的数值（如不使用设置多账户，默认只有subportfolios[0]一个账户，Portfolio 指向该账户。）
    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock_margin')])

    — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —

    ## 设置多个账户

    # 获取初始资金，并等分为三份
    init_cash = context.portfolio.starting_cash/3

    # 设定subportfolios[0]为 股票和基金仓位，初始资金为 init_cash 变量代表的数值
    # 设定subportfolios[1]为 金融期货仓位，初始资金为 init_cash 变量代表的数值
    # 设定subportfolios[2]为 融资融券账户，初始资金为 init_cash 变量代表的数值
    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock'),\
                       SubPortfolioConfig(cash=init_cash, type='index_futures'),\
                       SubPortfolioConfig(cash=init_cash, type='stock_margin')])
注意：get_marginsec_stocks和get_margincash_stocks无法获取当前未完结交易日的数据，因为交易所的数据尚未生成。

设置融资利率
set_option('margincash_interest_rate', value)
设定融资利率, 默认 8%

参数

value: 融资利率的值, 默认 8%
示例

# 设定融资利率: 年化8%
set_option('margincash_interest_rate', 0.08)
设置融资保证金比率
set_option('margincash_margin_rate', value)
设置融资保证金比率, 默认 100%

参数

value: 融资保证金比率的值, 默认 100%
示例

# 设置融资保证金比率: 150%
set_option('margincash_margin_rate', 1.5)
设置融券利率
set_option('marginsec_interest_rate', value)
设定融券利率: 年化 10%, 默认 10%

参数

value: 融券利率的值, 默认 10%
示例

# 设定融券利率: 年化10%
set_option('marginsec_interest_rate', 0.10)
设置融券保证金比率
set_option('marginsec_margin_rate', value)
设定融券保证金比率: 150%, 默认 100%

参数

value: 融券保证金比率的值, 默认 100%
示例

# 设定融券保证金比率: 150%
set_option('marginsec_margin_rate', 1.5)
margincash_open - 融资买入
margincash_open(security, amount, style=None, pindex=0)
融资买入

参数

security: 标的代码
amount: 数量
style: 参见[order styles], None代表MarketOrder
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
返回 Order对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None

示例

# 融资买入平安银行 1000 股
margincash_open('000001.XSHE', 1000)
margincash_close - 卖券还款
margincash_close(security, amount, style=None, pindex=0)
卖券还款

参数

security: 标的代码
amount: 数量
style: 参见[order styles], None代表MarketOrder
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
返回 None

示例

# 卖出 1000 股平安银行用以还款
margincash_close('000001.XSHE', 1000)
margincash_direct_refund - 直接还款
margincash_direct_refund(value, pindex=0)
直接还款

参数

value: 还款金额
返回 None

示例

# 还款 100000 元
margincash_direct_refund(100000)
marginsec_open - 融券卖出
marginsec_open(security, amount, style=None, pindex=0)
融券卖出

参数

security: 标的代码
amount: 数量
style: 参见[order styles], None代表MarketOrder
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
返回 Order对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None

示例

# 融券卖出 1000 股 平安银行
marginsec_open('000001.XSHE', 1000)
marginsec_close - 买券还券
marginsec_close(security, amount, style=None, pindex=0)
买券还券

参数

security: 标的代码
amount: 数量
style: 参见[order styles], None代表MarketOrder
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
返回 None

示例

# 买入 1000 股平安银行用以还券
marginsec_close('000001.XSHE', 1000)
marginsec_direct_refund - 直接还券
marginsec_direct_refund(security, amount, pindex=0)
直接还券

参数

security: 标的代码
amount: 数量
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
返回 None

示例

## 如果账户持仓中"有" 1000股 平安银行
# 直接还 1000 股平安银行
marginsec_direct_refund('000001.XSHE', 1000)

— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —

## 如果账户持仓中"没有" 1000股 平安银行
# 需先买入 1000 股平安银行
order('000001.XSHE', 1000)
# 再直接还 1000 股平安银行
marginsec_direct_refund('000001.XSHE', 1000)
get_margincash_stocks - 获取融资标的列表
get_margincash_stocks()
返回 返回上交所、深交所最近一次披露的的可融资标的列表的list。

示例

# 获取融资标的列表，并赋值给 margincash_stocks
margincash_stocks = get_margincash_stocks()

# 判断平安银行是否在可融资列表
>>> '000001.XSHE' in get_margincash_stocks()
>>> True
get_marginsec_stocks - 获取融券标的列表
get_marginsec_stocks()
返回 返回上交所、深交所最近一次披露的的可融券标的列表的list。

示例

# 获取融券标的列表，并赋值给 marginsec_stocks
marginsec_stocks= get_marginsec_stocks()

# 判断平安银行是否在可融券列表
>>> '000001.XSHE' in get_marginsec_stocks()
>>> True
get_mtss - 获取融资融券信息
from jqdata import *
get_mtss(security_list, start_date=None, end_date=None, fields=None, count=None)
获取一只或者多只股票在一个时间段内的融资融券信息

注： 需导入 jqdata 模块，即在策略或研究起始位置加入from jqdata import *

参数

security_list: 一只股票代码或者一个股票代码的 list
start_date: 开始日期, 与 count 二选一, 不可同时使用. 一个字符串或者 [datetime.datetime]/[datetime.date] 对象, 默认为平台提供的数据的最早日期
end_date: 结束日期, 一个字符串或者 [datetime.date]/[datetime.datetime] 对象, 默认为 datetime.date.today()
count: 数量, 与 start_date 二选一，不可同时使用, 必须大于 0. 表示返回 end_date 之前 count 个交易日的数据, 包含 end_date
fields: 字段名或者 list, 可选. 默认为 None, 表示取全部字段, 各字段含义如下：
字段名	含义
date	日期
sec_code	股票代码
fin_value	融资余额
fin_buy_value	融资买入额
fin_refund_value	融资偿还额
sec_value	融券余额
sec_sell_value	融券卖出额
sec_refund_value	融券偿还额
fin_sec_value	融资融券余额
返回

返回一个 [pandas.DataFrame] 对象，默认的列索引为取得的全部字段. 如果给定了 fields 参数, 则列索引与给定的 fields 对应.

示例

# 导入聚宽函数库
from jqdata import *

# 获取一只股票的融资融券信息
get_mtss('000001.XSHE', '2016-01-01', '2016-04-01')
get_mtss('000001.XSHE', '2016-01-01', '2016-04-01', fields=["date", "sec_code", "fin_value", "fin_buy_value"])
get_mtss('000001.XSHE', '2016-01-01', '2016-04-01', fields="sec_sell_value")

# 获取多只股票的融资融券信息
get_mtss(['000001.XSHE', '000002.XSHE', '000099.XSHE'], '2015-03-25', '2016-01-25')
get_mtss(['000001.XSHE', '000002.XSHE', '000099.XSHE'], '2015-03-25', '2016-01-25', fields=["date", "sec_code", "sec_value", "fin_buy_value", "sec_sell_value"])

# 获取股票 000001.XSHE 在日期 2016-06-30 往前 20 个交易日的融资融券信息
get_mtss('000001.XSHE', end_date="2016-06-30", count=20)
# 获取股票 000001.XSHE 往前 20 个交易日的融资融券信息
get_mtss('000001.XSHE', count=20)
期货策略专用函数
初始化期货账户
初始化的仓位是不允许直接买卖期货的，因为初始默认 subportfolios[0] 中 SubPortfolioConfig 的 type = 'stock'，只允许买卖股票与基金等。

因此要买卖期货，您需要设定 SubPortfolioConfig 的 type = 'futures'，具体方法如下：

def initialize(context):

    ## 设置单个账户

    # 获取初始资金
    init_cash = context.portfolio.starting_cash 

    # 设定账户为金融账户，初始资金为 init_cash 变量代表的数值（如不使用设置多账户，默认只有subportfolios[0]一个账户，Portfolio 指向该账户。）
    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='futures')])

    — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —

    ## 设置多个账户

    # 获取初始资金，并等分为三份
    init_cash = context.portfolio.starting_cash/3

    # 设定subportfolios[0]为 股票和基金仓位，初始资金为 init_cash 变量代表的数值
    # 设定subportfolios[1]为 金融期货仓位，初始资金为 init_cash 变量代表的数值
    # 设定subportfolios[2]为 融资融券账户，初始资金为 init_cash 变量代表的数值
    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock'),\
                       SubPortfolioConfig(cash=init_cash, type='futures'),\
                       SubPortfolioConfig(cash=init_cash, type='stock_margin')])
主力连续合约
期货合约的生存周期是有限的，到合约最后交易日后就要交割。因此我们根据持仓量对期货合约进行拼接，形成主力连续合约。

合约代码：品种代号+9999，例如AG9999(白银主力合约)、Y9999(豆油主力合约)。

主力合约定义：如果某合约持仓量连续2天为同一个品种中最大的，且该合约相对于当前主力合约为远期合约，则自动变成主力合约。不会在日内进行主力合约切换。

不可直接对主力合约进行下单。请使用get_dominant_future获取主力合约对应的具体合约。

下面是主要期货交易所的主力合约列表：

中金所

代码	名称	代码	名称
IC9999.CCFX	中证500主力合约	T9999.CCFX	10年期国债主力合约
IF9999.CCFX	沪深300主力合约	TF9999.CCFX	5年期国债主力合约
IH9999.CCFX	上证50主力合约	TS9999.CCFX	2年期国债主力合约
上海国际能源交易中心

代码	名称	代码	名称
SC9999.XINE	原油主力合约	-	-
上期所

代码	名称	代码	名称
AG9999.XSGE	白银主力合约	PB9999.XSGE	铅主力合约
AU9999.XSGE	黄金主力合约	RB9999.XSGE	螺纹钢主力合约
AL9999.XSGE	铝主力合约	RU9999.XSGE	天然橡胶主力合约
BU9999.XSGE	石油沥青主力合约	SN9999.XSGE	锡主力合约
CU9999.XSGE	铜主力合约	WR9999.XSGE	线材主力合约
FU9999.XSGE	燃料油主力合约	ZN9999.XSGE	锌主力合约
HC9999.XSGE	热轧卷板主力合约	NI9999.XSGE	镍主力合约
郑商所

代码	名称	代码	名称
CY9999.XZCE	棉纱主力合约	RM9999.XZCE	菜籽粕主力合约
CF9999.XZCE	棉花主力合约	FG9999.XZCE	玻璃主力合约
RS9999.XZCE	油菜籽主力合约	JR9999.XZCE	粳稻谷主力合约
SF9999.XZCE	硅铁主力合约	LR9999.XZCE	晚籼稻主力合约
SM9999.XZCE	锰硅主力合约	MA9999.XZCE	甲醇主力合约
SR9999.XZCE	白糖主力合约	ME9999.XZCE	甲醇主力合约[退市]
TA9999.XZCE	PTA主力合约	OI9999.XZCE	菜籽油主力合约
WH9999.XZCE	强麦主力合约	RO9999.XZCE	菜籽油主力合约[退市]
WS9999.XZCE	强麦主力合约[退市]	PM9999.XZCE	普麦主力合约
ZC9999.XZCE	动力煤主力合约	WT9999.XZCE	硬白小麦主力合约[退市]
TC9999.XZCE	动力煤主力合约[退市]	RI9999.XZCE	早籼稻主力合约
GN9999.XZCE	绿豆主力合约[退市]	ER9999.XZCE	早籼稻主力合约[退市]
AP9999.XZCE	苹果主力合约		
大商所

代码	名称	代码	名称
A9999.XDCE	豆一主力合约	JD9999.XDCE	鸡蛋主力合约
B9999.XDCE	豆二主力合约	JM9999.XDCE	焦煤主力合约
BB9999.XDCE	胶合板主力合约	L9999.XDCE	聚乙烯主力合约
C9999.XDCE	玉米主力合约	M9999.XDCE	豆粕主力合约
CS9999.XDCE	玉米淀粉主力合约	P9999.XDCE	棕榈油主力合约
FB9999.XDCE	纤维板主力合约	PP9999.XDCE	聚丙烯主力合约
I9999.XDCE	铁矿石主力合约	V9999.XDCE	聚氯乙烯主力合约
J9999.XDCE	焦炭主力合约	Y9999.XDCE	豆油主力合约
品种指数
下面是主要期货交易所的期货指数列表：

中金所

代码	名称	代码	名称
IC8888.CCFX	中证500期货指数	T8888.CCFX	10年期国债期货指数
IF8888.CCFX	沪深300期货指数	TF8888.CCFX	5年期国债期货指数
IH8888.CCFX	上证50期货指数	-	-
上海国际能源交易中心

代码	名称	代码	名称
SC8888.XINE	原油期货指数	-	-
上期所

代码	名称	代码	名称
AG8888.XSGE	白银期货指数	PB8888.XSGE	铅期货指数
AU8888.XSGE	黄金期货指数	RB8888.XSGE	螺纹钢期货指数
AL8888.XSGE	铝期货指数	RU8888.XSGE	天然橡胶期货指数
BU8888.XSGE	石油沥青期货指数	SN8888.XSGE	锡期货指数
CU8888.XSGE	铜期货指数	WR8888.XSGE	线材期货指数
FU8888.XSGE	燃料油期货指数	ZN8888.XSGE	锌期货指数
HC8888.XSGE	热轧卷板期货指数	NI8888.XSGE	镍期货指数
郑商所

代码	名称	代码	名称
CY8888.XZCE	棉纱期货指数	RM8888.XZCE	菜籽粕期货指数
CF8888.XZCE	棉花期货指数	FG8888.XZCE	玻璃期货指数
RS8888.XZCE	油菜籽期货指数	JR8888.XZCE	粳稻谷期货指数
SF8888.XZCE	硅铁期货指数	LR8888.XZCE	晚籼稻期货指数
SM8888.XZCE	锰硅期货指数	MA8888.XZCE	甲醇期货指数
SR8888.XZCE	白糖期货指数	ME8888.XZCE	甲醇期货指数[退市]
TA8888.XZCE	PTA期货指数	OI8888.XZCE	菜籽油期货指数
WH8888.XZCE	强麦期货指数	RO8888.XZCE	菜籽油期货指数[退市]
WS8888.XZCE	强麦期货指数[退市]	PM8888.XZCE	普麦期货指数
ZC8888.XZCE	动力煤期货指数	WT8888.XZCE	硬白小麦期货指数[退市]
TC8888.XZCE	动力煤期货指数[退市]	RI8888.XZCE	早籼稻期货指数
GN8888.XZCE	绿豆期货指数[退市]	ER8888.XZCE	早籼稻期货指数[退市]
AP8888.XZCE	苹果期货指数		
大商所

代码	名称	代码	名称
A8888.XDCE	豆一期货指数	JD8888.XDCE	鸡蛋期货指数
B8888.XDCE	豆二期货指数	JM8888.XDCE	焦煤期货指数
BB8888.XDCE	胶合板期货指数	L8888.XDCE	聚乙烯期货指数
C8888.XDCE	玉米期货指数	M8888.XDCE	豆粕期货指数
CS8888.XDCE	玉米淀粉期货指数	P8888.XDCE	棕榈油期货指数
FB8888.XDCE	纤维板期货指数	PP8888.XDCE	聚丙烯期货指数
I8888.XDCE	铁矿石期货指数	V8888.XDCE	聚氯乙烯期货指数
J8888.XDCE	焦炭期货指数	Y8888.XDCE	豆油期货指数
期货注意事项
有夜盘的商品期货的一个交易日从前一天晚上 21:00 开始
每日在16:00:00结算, 对于期货, 使用结算价结算
期货持仓到交割日，没有手动交割，系统会以当天结算价平仓, 没有手续费, 不会有交易记录
股指期货平今手续费默认为万分之六点九
获取主力合约对应的标的
get_dominant_future(underlying_symbol, date=None)
参数

underlying_symbol: 期货合约品种，如 'AG'(白银)
date: 查询日期，回测模块中不可填，日期为回测的日期；研究模块中为可选项，默认为最新日期，也可指定日期。
返回

主力合约对应的期货合约
示例

# 获取某一天的主力合约对应的期货合约代码（策略当前日期是20160801）
>>> get_dominant_future('IF')

# 输出
'IF1608.CCFX'
期货可交易合约列表
get_future_contracts(underlying_symbol, dt=None)
获取某期货品种在策略当前日期的可交易合约标的列表

参数

security: 期货合约品种，如 'AG'(白银)
dt: 查询日期，回测模块中不可填，日期为回测的日期；研究模块中为可选项，默认为最新日期，也可指定日期。
返回

某期货品种在策略当前日期的可交易合约标的列表
示例

# 获取某一天的主力合约对应的期货合约代码（策略当前日期是20160601）
get_future_contracts('IF')

# 输出
[u'IF1606.CCFX', u'IF1607.CCFX', u'IF1609.CCFX', u'IF1612.CCFX']
设置期货保证金比例
set_option('futures_margin_rate', value)
设置期货保证金比例。可为不同品种的标的设置不同比例的保证金。

参数

value: value 是一个 float 值，为期货的保证金比例。
示例

# 设定期货保证金比例
set_option('futures_margin_rate', 0.25) # 设定期货保证金比例为25%
set_option('futures_margin_rate.AU1709', 0.08)# 设定合约AU1709保证金比例为8%
set_option('futures_margin_rate.AU', 0.09)# 设定所有黄金期货保证金比例为9%
set_option('futures_margin_rate', 0.1)# 设定所有期货保证金比例为10%
set_option('futures_margin_rate.IF', 0.15)# 设定所有股指期货保证金比例为15%
不设置时，股指期货默认值 0.15 ；商品期货默认保证金比例如下：

A  0.07
AG  0.04
AL  0.05
AU  0.04
B  0.05
BB  0.2
BU  0.04
C  0.07
CF  0.05
CS  0.07
CU  0.05
FB  0.2
FG  0.05
FU  0.08
HC  0.04
I  0.1
J  0.12
JD  0.08
JM  0.12
JR  0.05
L  0.07
LR  0.05
M  0.07
MA  0.05
NI  0.05
OI  0.05
P  0.05
PB  0.05
PM  0.05
PP  0.07
RB  0.05
RI  0.05
RM  0.05
RS  0.05
RU  0.05
SF  0.05
SM  0.05
SN  0.05
SR  0.05
TA  0.05
V  0.07
WH  0.05
WR  0.07
Y  0.05
ZC  0.05
ZN  0.05
期货保证金预警
判断指定仓位，是否低于指定的保证金比率，高于该比例返回False，低于该比例返回True.

context.subportfolios[i].is_dangerous(margin_rate)
其中 i 是要查询的仓位编号, margin_rate 是要查询的保证金比例

返回： True 或 False

示例：

# 查询 subportfolios[1] 中保证金是否低于 20%
context.subportfolios[1].is_dangerous(0.2)

# 低于则返回True， 高则返回 False
获取期货的行情数据
获取期货行情与获取股票行情的方法相同， get_price、history、attribute_history、get_current_data、get_bars 等 API 均可正常使用。

order - 期货按股数下单
order(security, amount, style=None, side='long', pindex=0)
买卖标的。调用成功后, 您将可以调用[get_open_orders]取得所有未完成的交易, 也可以调用[cancel_order]取消交易

参数

security: 标的代码
amount: 交易数量, 正数表示买入, 负数表示卖出
style: 参见[order styles], None代表MarketOrder
side: 'long'/'short'，操作多单还是空单，默认为多单。
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0 指定第一个 subportfolio, 1 指定第二个 subportfolio，默认为0。
返回 Order对象或者None, 如果创建订单成功, 则返回Order对象, 失败则返回None

示例

## 如果期货账户是默认账户
# 在仓位0中开一手沪深300指数期货的空单
order('IF1412.CCFX', 1 , side='short', pindex=0)

# 在仓位0中开一手沪深300指数期货的多单
order('IF1412.CCFX', 1 , side='long', pindex=0)

## 如果期货账户是仓位1
# 在仓位1中以3600的限价单，平一手沪深300指数期货的空单
order('IF1412.CCFX', -1 , LimitOrderStyle(3600.0), side='short', pindex=1)

# 在仓位1中平一手沪深300指数期货的多单
order('IF1412.CCFX', -1 , side='long', pindex=1)
可能的失败原因:

标的不存在，对于该原因, 我们会抛出异常停止运行, 因为我们认为这是您代码的bug.
选择了不存在的仓位号，如没有建立多个仓位，而设定pindex的数大于0
注意:

因为下列原因, 有时候实际买入或者卖出的股票数量跟您设置的不一样，这个时候我们会在您的log中添加警告信息。
买入时会根据您当前的现金来限制您买入的数量
卖出时会根据您持有股票的数量来限制您卖出的数量
我们会遵守A股交易规则: 每次交易数量只能是100的整数倍, 但是卖光所有股票时不受这个限制
根据交易所规则, 每天结束时会取消所有未完成交易
order_target - 期货目标股数下单
order_target(security, amount, style=None, side='long', pindex=0)
买卖标的, 使最终标的的数量达到指定的amount

参数

security: 标的代码
amount: 期望的最终数量
style: 参见[order styles], None代表MarketOrder
side: 'long'/'short'，操作多单还是空单，默认为多单。
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
返回 Order对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None

注意：使用order_target进行开平仓时，请直接对目标方向进行操作，请看示例。

示例

# 开5手多单
order_target('IF1412.CCFX', 5 , side='long', pindex=1)
# 平1手多单
order_target('IF1412.CCFX', 4 , side='long', pindex=1)
# 再开5手空单，操作完成后持有多单4手，空单5手
order_target('IF1412.CCFX', 5 , side='short', pindex=1)
# 平1手空单，操作完成后持有多单4手，空单4手
order_target('IF1412.CCFX', 4 , side='short', pindex=1)
order_value - 期货按价值下单
order_value(security, value, style=None, side='long', pindex=0, close_today=False)
买卖价值为value的标的。

参数

security: 股票名字
value: 股票价值
style: 参见[order styles], None代表MarketOrder
side: 'long'/'short'，操作多单还是空单。默认为多单，股票、基金暂不支持开空单。
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
close_today: 平今字段。
close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓
close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓
close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错
返回 Order对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None

示例

# 开市值5000000多单
order_value('IF1412.CCFX', 5000000 , side='long', pindex=1)
# 平市值4000000多单
order_value('IF1412.CCFX', -4000000, side='long', pindex=1)
order_target_value - 期货目标价值下单
order_target_value(security, value, style=None, side='long', pindex=0, close_today=False)
调整标的仓位到value价值。

参数

security: 标的名字
value: 期望的标的最终价值
style: 参见[order styles], None代表MarketOrder
side: 'long'/'short'，操作多单还是空单。
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0为 指定第一个 subportfolio, 1 为指定第二个 subportfolio，默认为0。
close_today: 平今字段。
close_today = True, 对非上期所交易的期货标的优先平今，超出则平昨仓，上期所交易的期货标的则仅仅表示平今仓
close_today = False, 对非上期所交易的期货标的优先平昨，超出则平今仓，上期所交易的期货标的则仅仅表示平昨仓
close_today仅仅对上海国际能源中心，上海期货交易所，中金所起作用，平仓数量超出则报错
返回 Order对象或者None, 如果创建委托成功, 则返回Order对象, 失败则返回None

示例

# 将IF1412.CCFX的多单市值调整至5000000
order_target_value('IF1412.CCFX',5000000, side='long', pindex=1)
# 将IF1412.CCFX的多单市值调整至4000000
order_target_value('IF1412.CCFX', 4000000, side='long', pindex=1)
# 平掉IF1412.CCFX的多单
order_target_value('IF1412.CCFX', 0 , side='long', pindex=1)
场外基金策略专用函数
请使用 get_extras 获取场外基金的净值信息。
在进行申购与赎回操作前， 需要先使用 set_subportfolios 设置独立的场外基金仓位。
在申购与赎回份额时， 使用 purchase 和 redeem 两个 API 实现。

场外基金成交价格说明
非QDII基金，今日申购，按今天的收盘净值价格进行撮合
非QDII基金，今日只能拿到昨天的净值，延迟T+1，因此撮合成交在第二天
QDII基金，今日可以拿到前天的净值，延迟T+2，因此撮合成交在第三天
purchase - 申购基金
purchase(security, cash, pindex=0)
申购基金API接口

参数

security: 基金代码编号，OF作为尾缀的字符串，例如招商中证白酒指数分级基金为“161725.OF"
cash: 申购的金额
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0 指定第一个 subportfolio, 1 指定第二个 subportfolio，默认为0
返回

Order对象或者None, 如果创建订单成功, 则返回Order对象, 失败则返回None
说明

目前暂时没有考虑T+0交易的场外货币基金

非QDII基金，份额T+2到账并可以卖出
QDII基金，份额T+3到账并可以卖出
redeem - 赎回基金
redeem(security, amount，pindex=0)
赎回基金API接口

参数

security: 基金代码编号，OF作为尾缀的字符串，例如招商中证白酒指数分级基金为“161725.OF"
amount: 赎回的份额
pindex: 在使用set_subportfolios创建了多个仓位时，指定subportfolio 的序号, 从 0 开始, 比如 0 指定第一个 subportfolio, 1 指定第二个 subportfolio，默认为0
返回

Order对象或者None, 如果创建订单成功, 则返回Order对象, 失败则返回None
set_redeem_latency - 设置赎回到账日
set_redeem_latency(day，type, ref=None)
设置指定类型基金的赎回到帐日，默认的赎回到帐日：非货币基金：T+4，QDII:T+7，货币型基金:T+2

参数

day: int 类型，例如，day=4 表示 T+4 日到账，赎回到账时间至少是2天。
type: 可操作的场外基金类型，取值不可为空，可以包含多种场外基金的类型'bond_fund'/'stock_fund'/'QDII_fund'/'money_market_fund'/'mixture_fund'/'open_fund'，其中 bond_fund指债券基金，stock_fund指股票型基金，QDII_fund指QDII基金，money_market_fund指货币基金，mixture_fund指混合型基金，open_fund则泛指所有的场外基金，如果不清楚具体操作的场外基金的类型，可以使用open_fund
ref: 参考代码，仅支持场外基金代码，如 '000300.OF'，类型为字符串，不能用列表填入一组场外基金。取值可以为空，当ref为空时，表示设置的到账时间对type类型中场外基金生效，其他type类型的场外基金使用默认值，如果不为空，则表示对type类型下的ref基金生效，除ref基金以外的其他场外基金使用默认值，包括type类型中除ref以外的其他场外基金。
返回

None
示例

# 设置股票型基金的到帐日为 T+7 
set_redeem_latency(day=7, type='stock_fund')

# 设置股票型基金中的000697.OF 的到帐日为 T+5
set_redeem_latency(day=5, type='stock_fund',ref='000697.OF')
get_fund_info - 基金基础信息数据接口
get_fund_info(security, date=None)
获取单个基金的基本信息

参数

security: 基金代码
date: 查询日期, 一个字符串(格式类似’2015-10-15’)或者datetime.date/datetime.datetime对象, 可以是None, 使用默认日期。回测模块中， 默认日期等于 context.current_dt。 研究模块中， 默认日期是今天。
返回 dict, 各 key 的含义如下：

fund_name: 基金全称
fund_type: 基金类型
fund_establishment_day: 基金成立日
fund_manager: 基金管理人及基本信息
fund_management_fee: 基金管理费
fund_custodian_fee: 基金托管费
fund_status: 基金申购赎回状态
fund_size: 基金规模（季度）
fund_share: 基金份额（季度）
fund_asset_allocation_proportion: 基金资产配置比例（季度）
heavy_hold_stocks: 基金重仓股（季度）
heavy_hold_stocks_proportion: 基金重仓股占基金资产净值比例（季度）
heavy_hold_bond: 基金重仓债券（季度）
heavy_hold_bond_proportion: 基金重仓债券占基金资产净值比例（季度）
场外基金示例策略
# 导入函数库
import jqdata

# 初始化
def initialize(context):
    g.day = 0
    # 初始化场外基金仓位
    set_subportfolios([SubPortfolioConfig(context.portfolio.cash, 'open_fund')])
    # 设置 QDII 的赎回到账日为 T+3
    set_redeem_latency(3, 'QDII_fund')

def handle_data(context, data):
    s = '000311.OF'
    if g.day == 1:
        o = purchase(s, 100000)
        print o
    if g.day == 10:
        o2 = redeem(s, 500)
        print o2
    print context.current_dt
    print context.portfolio.cash
    print context.portfolio.total_value
    g.day += 1
Python库
标准库
我们支持所有Python标准库(https://docs.python.org/2/library/index.html)，您可以通过import的方式进行引入, 下面列出了一些常用的库：

库名	帮助文档
array	https://docs.python.org/2.7/library/array.html
cmath	https://docs.python.org/2.7/library/cmath.html
collections	https://docs.python.org/2.7/library/collections.html
copy	https://docs.python.org/2.7/library/copy.html
datetime	https://docs.python.org/2.7/library/datetime.html
dateutil	https://pypi.python.org/pypi/dateutils/0.6.6
functools	https://docs.python.org/2.7/library/functools.html
heapq	https://docs.python.org/2.7/library/heapq.html
itertools	https://docs.python.org/2.7/library/itertools.html
json	https://docs.python.org/2.7/library/json.html
math	https://docs.python.org/2.7/library/math.html
operator	https://docs.python.org/2.7/library/operator.html
pytz	https://pypi.python.org/pypi/pytz/2015.2
random	https://docs.python.org/2.7/library/random.html
re	https://docs.python.org/2.7/library/re.html
string	https://docs.python.org/2.7/library/string.html
time	https://docs.python.org/2.7/library/time.html
xml	https://docs.python.org/2.7/library/xml.html
第三方库
我们支持以下Python第三方库，您可以通过import的方式进行引入: 在研究模拟中, 您可以运行 !pip list 来查看所有安装的第三库和版本.

回测模块：

anyjson, arch, graphviz, Lasagne, numpy, pandas, pybrain, scipy, seaborn, sklearn, statsmodels, talib, tushare, theano, requests, hmm, hmmlearn, pywt, pycrypto, beautifulsoup4, prettytable, xlrd

研究模块：

anyjson, arch, beautifulsoup4, cvxopt, graphviz, gensim, jieba, matplotlib, mpl_toolkits, numpy, pandas, pybrain, pymc, pillow, scipy, seaborn, sklearn, statsmodels, tables, talib, hmm, hmmlearn, tushare, theano, Lasagne, requests, pywt, zipline, xlrd, xlwt, openpyxl, snownlp, pycrypto, prettytable, seaborn, bokeh

主要模块介绍：

模块名称	版本	简介	网址
arch	3.1	Arch模型的lib库	https://pypi.python.org/pypi/arch
cvxopt	1.1.8	cvxopt是一个最优化计算包，进行线性规划、二次规划、半正定规划等的计算	https://pypi.python.org/pypi/cvxopt/1.1.8
gensim	0.12.2	gensim用于计算文本相似度，依赖NumPy和SciPy这两大Python科学计算工具包	http://radimrehurek.com/gensim/tutorial.html
jieba	0.37	jieba是一个中文分词组件	https://pypi.python.org/pypi/jieba
matplotlib	1.4.3	matplotlib可能是Python 2D绘图领域使用最广泛的库。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式	http://matplotlib.org/contents.html
mpl_toolkits	1.4.3	mpl_toolkits是一个Python 3D绘图领域函数库	http://matplotlib.org/mpl_toolkits/index.html
NumPy	1.9.3	NumPy系统是Python的一种开源的数值计算扩展。NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库。专为进行严格的数字处理而产生	http://www.numpy.org/
pandas	0.16.2	Python Data Analysis Library 或 pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。pandas提供了大量能使我们快速便捷地处理数据的函数和方法	http://pandas.pydata.org/pandas-docs/version/0.16.2/
pybrain	0.3	pybrain一个开源的Python神经网络库	http://pybrain.org/docs/
pymc	2.3.6	pymc是机器学习中一个图模型的Python库	https://pypi.python.org/pypi/pymc/
SciPy	0.15.1	SciPy是一款方便、易于使用、专为科学和工程设计的Python工具包。它包括统计，优化，整合，线性代数模块，傅里叶变换，信号和图像处理,常微分方程求解器等等	http://www.scipy.org/
seaborn	0.6.0	该模块是一个统计数据可视化库	http://web.stanford.edu/~mwaskom/software/seaborn/
sklearn	0.18	Scikit-Learn是基于python的机器学习模块，基于BSD开源许可证。scikit-learn的基本功能主要被分为六个部分，分类，回归，聚类，数据降维，模型选择，数据预处理。Scikit-Learn中的机器学习模型非常丰富，包括SVM，决策树，GBDT，KNN等等，可以根据问题的类型选择合适的模型	http://scikit-learn.org/stable/
Statsmodels	0.6.1	Statismodels是一个Python包，提供一些互补scipy统计计算的功能，包括描述性统计和统计模型估计和推断	http://statsmodels.sourceforge.net/
PyTables	3.2.2	PyTables提供了一些用于结构化数组的高级查询功能，而且还能添加列索引以提升查询速度，这跟关系型数据库所提供的表索引功能非常类似	http://www.pytables.org/usersguide/tutorials.html
TALib	0.4.9	TALib是一个处理金融数据和技术分析的开放代码库	http://mrjbq7.github.io/ta-lib/funcs.html
hmmlearn	0.2.0	是在python上实现隐马可夫模型的一个组件包	https://github.com/hmmlearn/hmmlearn
Theano	0.8.1	Pyhton深度学习库	http://deeplearning.net/software/theano/
Lasagne	0.1	Pyhton深度学习库	http://lasagne.readthedocs.org/en/latest/
requests	2.7.0	网络访问模块	http://docs.python-requests.org/en/v2.7.0/
pywt	0.4.0	小波工具箱	http://pywavelets.readthedocs.io/en/v0.4.0/
Zipline	0.9.0	开源的交易算法库，目前作为Quantopian的回溯检验引擎	https://github.com/quantopian/zipline
xlrd	1.0.0	Python语言中，读取Excel的扩展工具	https://pypi.python.org/pypi/xlrd/
xlwt	1.1.2	Python语言中，写入Excel文件的扩展工具	https://pypi.python.org/pypi/xlwt/
openpyxl	2.4.0	Openpyxl是一个python读写Excel 2010文件的库	http://openpyxl.readthedocs.io/en/default/
snownlp	0.12.3	处理中文文本的Python库	https://pypi.python.org/pypi/snownlp/
pycrypto	2.6.2	Python加密工具包	https://pypi.python.org/pypi/pycrypto
beautifulsoup4	4.5.1	python下很帅气的爬虫包	https://www.crummy.com/software/BeautifulSoup/
prettytable	0.7.2	Python通过prettytable模块可以将输出内容如表格方式整齐的输出。	https://pypi.python.org/pypi/PrettyTable
PyBrain	0.3	Python的一个机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。	http://www.pybrain.org/
seaborn	0.6.0	基于matplotlib的Python可视化库	http://seaborn.pydata.org/
bokeh	0.9.3	Python可视化库, 长于创建交互式图表	http://bokeh.pydata.org/
共享函数库
用户产生的函数，并分享出来。 使用共享函数库，可以避免用户再做重复的工作，也可以学习其他宽客的代码思路。 详情查看：帮助 -> 共享函数库

策略示例
均线策略
当价格高于5日均线平均价格1.05时买入，当价格低于5日平均价格0.95时卖出。

# 导入聚宽函数库
import jqdata

# 初始化函数，设定要操作的股票、基准等等
def initialize(context):
    # 定义一个全局变量, 保存要操作的股票
    # 000001(股票:平安银行)
    g.security = '000001.XSHE'
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)

# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次
def handle_data(context, data):
    security = g.security
    # 获取股票的收盘价
    close_data = attribute_history(security, 5, '1d', ['close'])
    # 取得过去五天的平均价格
    MA5 = close_data['close'].mean()
    # 取得上一时间点价格
    current_price = close_data['close'][-1]
    # 取得当前的现金
    cash = context.portfolio.cash

    # 如果上一时间点价格高出五天平均价5%, 则全仓买入
    if current_price > 1.05*MA5:
        # 用所有 cash 买入股票
        order_value(security, cash)
        # 记录这次买入
        log.info("Buying %s" % (security))
    # 如果上一时间点价格低于五天平均价, 则空仓卖出
    elif current_price < 0.95*MA5 and context.portfolio.positions[security].closeable_amount > 0:
        # 卖出所有股票,使这只股票的最终持有量为0
        order_target(security, 0)
        # 记录这次卖出
        log.info("Selling %s" % (security))
    # 画出上一时间点价格
    record(stock_price=current_price)
多股票持仓示例
这是一个较简单的多股票操作示例，当价格高于三天平均价1.005则买入100股，当价格小于三天平均价0.995则卖出。

# 导入聚宽函数库
import jqdata

def initialize(context):
    # 初始化此策略
    # 设置我们要操作的股票池
    g.stocks = ['000001.XSHE','000002.XSHE','000004.XSHE','000005.XSHE']
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)

# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次
def handle_data(context, data):
    # 循环每只股票
    for security in g.stocks:
        # 得到股票之前3天的平均价
        vwap = data[security].vwap(3)
        # 得到上一时间点股票平均价
        price = data[security].close
        # 得到当前资金余额
        cash = context.portfolio.cash

        # 如果上一时间点价格小于三天平均价*0.995，并且持有该股票，卖出
        if price < vwap * 0.995 and context.portfolio.positions[security].closeable_amount > 0:
            # 下入卖出单
            order(security,-100)
            # 记录这次卖出
            log.info("Selling %s" % (security))
        # 如果上一时间点价格大于三天平均价*1.005，并且有现金余额，买入
        elif price > vwap * 1.005 and cash > 0:
            # 下入买入单
            order(security,100)
            # 记录这次买入
            log.info("Buying %s" % (security))
多股票追涨策略
当股票在当日收盘30分钟内涨幅到达9.5%~9.9%时间段的时候，我们进行买入，在第二天开盘卖出。注意：请按照分钟进行回测该策略。

# 导入聚宽函数库
import jqdata

# 初始化程序, 整个回测只运行一次
def initialize(context):
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)

    # 每天买入股票数量
    g.daily_buy_count  = 5

    # 设置我们要操作的股票池, 这里我们操作多只股票，下列股票选自计算机信息技术相关板块
    g.stocks = get_industry_stocks('I64') + get_industry_stocks('I65')

    # 防止板块之间重复包含某只股票, 排除掉重复的, g.stocks 现在是一个集合(set)
    g.stocks = set(g.stocks)

    # 让每天早上开盘时执行 morning_sell_all
    run_daily(morning_sell_all, 'open')

def morning_sell_all(context):
    # 将目前所有的股票卖出
    for security in context.portfolio.positions:
        # 全部卖出
        order_target(security, 0)
        # 记录这次卖出
        log.info("Selling %s" % (security))

def before_trading_start(context):
    # 今天已经买入的股票
    g.today_bought_stocks = set()

    # 得到所有股票昨日收盘价, 每天只需要取一次, 所以放在 before_trading_start 中
    g.last_df = history(1,'1d','close',g.stocks)

# 在每分钟的第一秒运行, data 是上一分钟的切片数据
def handle_data(context, data):

    # 判断是否在当日最后的2小时，我们只追涨最后2小时满足追涨条件的股票
    if context.current_dt.hour < 13:
        return

    # 每天只买这么多个
    if len(g.today_bought_stocks) >= g.daily_buy_count:
        return

    # 只遍历今天还没有买入的股票
    for security in (g.stocks - g.today_bought_stocks):

        # 得到当前价格
        price = data[security].close

        # 获取这只股票昨天收盘价
        last_close = g.last_df[security][0]

        # 如果上一时间点价格已经涨了9.5%~9.9%
        # 今天的涨停价格区间大于1元，今天没有买入该支股票
        if price/last_close > 1.095 \
                and price/last_close < 1.099 \
                and data[security].high_limit - last_close >= 1.0:

            # 得到当前资金余额
            cash = context.portfolio.cash

            # 计算今天还需要买入的股票数量
            need_count = g.daily_buy_count - len(g.today_bought_stocks)

            # 把现金分成几份,
            buy_cash = context.portfolio.cash / need_count

            # 买入这么多现金的股票
            order_value(security, buy_cash)

            # 放入今日已买股票的集合
            g.today_bought_stocks.add(security)

            # 记录这次买入
            log.info("Buying %s" % (security))

            # 买够5个之后就不买了
            if len(g.today_bought_stocks) >= g.daily_buy_count:
                break
万圣节效应策略
股市投资中的“万圣节效应”是指在北半球的冬季(11月至4月份)，股市回报通常明显高於夏季(5月至10月份)。这里我们选取了中国蓝筹股，采用10月15日后买入，5月15日后卖出的简单策略进行示例。

# 导入聚宽函数库
import jqdata

# 初始化此策略
def initialize(context):
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)

    # 设置我们要操作的股票池，这里我们选择蓝筹股
    g.stocks = ['000001.XSHE','600000.XSHG','600019.XSHG','600028.XSHG','600030.XSHG','600036.XSHG','600519.XSHG','601398.XSHG','601857.XSHG','601988.XSHG']

# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次
def handle_data(context, data):
    # 得到每只股票可以花费的现金，这里我们使用总现金股票数数量
    cash = context.portfolio.cash / len(g.stocks)
    # 获取数据
    hist = history(1,'1d','close',g.stocks)
    # 循环股票池
    for security in g.stocks:
        # 得到当前时间
        today = context.current_dt
        # 得到该股票上一时间点价格
        current_price = hist[security][0]
        # 如果当前为10月且日期大于15号，并且现金大于上一时间点价格，并且当前该股票空仓
        if today.month == 10 and today.day > 15 and cash > current_price and context.portfolio.positions[security].closeable_amount == 0:
            order_value(security, cash)
            # 记录这次买入
            log.info("Buying %s" % (security))
        # 如果当前为5月且日期大于15号，并且当前有该股票持仓，则卖出
        elif today.month == 5 and today.day > 15 and context.portfolio.positions[security].closeable_amount > 0:
            # 全部卖出
            order_target(security, 0)
            # 记录这次卖出
            log.info("Selling %s" % (security))